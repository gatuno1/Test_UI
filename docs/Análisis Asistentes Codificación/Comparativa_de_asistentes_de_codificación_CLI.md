# Comparativa de asistentes de codificación CLI: Claude Code, Gemini CLI y GitHub Copilot CLI

**Fecha del informe:** 21 de agosto de 2025
**Asistentes analizados:** *Claude Code* (Anthropic) v1.0.86, *Gemini CLI* (Google) v0.3.0 (proyecto de código abierto), *GitHub Copilot CLI* (GitHub) v1.1.1.

## Introducción

En este informe se comparan las capacidades de tres asistentes de codificación de última generación que operan desde la línea de comandos e integran su funcionalidad con entornos de desarrollo como Visual Studio Code. Estas herramientas –Claude Code de Anthropic, Gemini CLI de Google y GitHub Copilot CLI de GitHub– funcionan como “parejas de programación” impulsadas por IA en el terminal, permitiendo a los desarrolladores describir en lenguaje natural tareas de desarrollo de software que el asistente puede ejecutar o asistir de forma autónoma.

Se analizarán las categorías clave de cada asistente, incluyendo su integración con Visual Studio Code (y compatibilidad con sistemas operativos, particularmente Windows), los comandos incorporados y herramientas que ofrecen, sus opciones de extensibilidad (por ejemplo, soporte para el protocolo *Model Context Protocol* - MCP - o integración con programas locales), la posibilidad de definir acciones personalizadas mediante archivos de texto/Markdown, la capacidad de generar sub-agentes especializados, y el soporte que brindan para diversos casos de uso en el ciclo de vida del desarrollo de software. A lo largo del análisis se citan la documentación oficial y experiencias de usuarios para sustentar cada afirmación.

## Categorías de análisis

A continuación, se enumeran las categorías en las que evaluaremos a Claude Code, Gemini CLI y GitHub Copilot CLI:

- **Instalación e integración con VS Code:** cómo se instalan y configuran en distintos entornos (incluyendo Windows) y qué nivel de integración proporcionan con Visual Studio Code u otros IDEs (extensiones, atajos, características específicas en el editor).
- **Comandos y herramientas incorporados:** qué comandos nativos ofrece cada asistente (ej. comandos “slash” o alias especiales) y qué acciones pueden realizar de forma autónoma (leer/escribir código, ejecutar comandos shell, realizar búsquedas web, etc.).
- **Extensibilidad y herramientas externas:** capacidad de cada asistente para ampliarse o conectarse con herramientas adicionales, ya sea mediante protocolos estándar (p. ej. MCP), integración con acciones de CI/CD, llamadas a programas locales, etc.
- **Configuración mediante archivos Markdown:** uso de archivos de configuración en texto plano (por ejemplo, `*.md` con front-matter YAML u otros formatos) para personalizar el comportamiento de los asistentes o definir instrucciones permanentes.
- **Sub-agentes especializados:** posibilidad de definir o generar agentes secundarios con roles especializados (por ejemplo, un sub-agente enfocado en revisión de código o generación de pruebas) que puedan ser invocados según la tarea.
- **Cobertura de casos de uso específicos:** evaluación de cómo cada herramienta puede abordar escenarios de uso deseados, tales como análisis de requerimientos (detección de contradicciones o especificaciones faltantes), generación de código a partir de especificaciones, revisión de código con estándares y buenas prácticas, depuración de código, generación de pruebas unitarias basadas en requerimientos, refactorización guiada por requisitos, análisis de cambios en commits de Git, y gestión de solicitudes de cambio en requerimientos.

Cada categoría incluirá el análisis de las capacidades de los tres asistentes, con referencias a fuentes oficiales o reconocidas, seguido de tablas comparativas para visualizar las diferencias clave entre las herramientas.

## Instalación e integración con Visual Studio Code

**Claude Code (Anthropic):** Claude Code se distribuye como un paquete NPM global (`@anthropic-ai/claude-code`) y a la fecha de este informe se encuentra en la versión 1.0.86[<sup>{1}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=1)[<sup>{2}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=Version). Se instala con Node.js (requisito Node 18+) usando `npm install -g @anthropic-ai/claude-code`[<sup>{3}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=settings%20with%20sensitive%20code.%20,start%20an%20interactive%20CLI%20session). Para integrarlo con Visual Studio Code, simplemente se ejecuta el comando `claude` en la terminal integrada de VS Code; esto dispara la auto-instalación de la extensión de Claude Code para VS Code si no está ya instalada[<sup>{4}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=VSCodium%3A)[<sup>{5}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=2,install). La extensión proporciona atajos y mejoras en el editor, como apertura rápida de la interfaz con **Ctrl+Esc** (Windows/Linux) o **Cmd+Esc** (Mac), visualización de *diffs* de código sugeridos directamente en el visor de diferencias de VS Code, compartir automáticamente con Claude el fragmento de código seleccionado en el editor, e incluso inserción rápida de referencias a archivos/líneas con un atajo dedicado[<sup>{6}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=Features)[<sup>{7}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=shared%20with%20Claude%20Code%20,with%20Claude%20as%20you%20work). Claude Code también es compatible con otras IDEs populares (p. ej. JetBrains IDEs) mediante plugins específicos[<sup>{8}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Studio%2C%20WebStorm%2C%20PhpStorm%20and%20GoLand)[<sup>{9}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=To%20install%20Claude%20Code%20on,marketplace%20and%20restart%20your%20IDE). Es multiplataforma: puede ejecutarse en sistemas Windows (incluso WSL), macOS y Linux, dado que corre sobre Node.js (Anthropic recomienda asegurarse de tener disponible el comando `code` en el PATH de Windows para la instalación correcta de la extensión de VS Code[<sup>{10}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Install%20%E2%80%98code%E2%80%99%20command%20in%20PATH%E2%80%9D)).

**Gemini CLI (Google):** Gemini CLI se lanzó como una herramienta de código abierto (licencia Apache 2.0) anunciada oficialmente el 25 de junio de 2025[<sup>{11}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Gemini%20CLI%3A%20Google%27s%20Open). Su instalación es similar, vía NPM global (`npm install -g @google/gemini-cli`)[<sup>{12}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=hackable%20and%20integrable.%20,changer%20in%20this%20space), y luego se inicia con el comando `gemini`. En Windows, macOS o Linux se requiere Node.js (mín. Node 16). Para autenticación, ofrece varias opciones: login OAuth con cuenta de Google (otorga automáticamente un *free tier* generoso de hasta 1000 peticiones/día usando el modelo Gemini 2.5 Pro) o uso de claves de API de Google AI/Vertex AI para planes pagos o empresariales[<sup>{13}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Choose%20the%20authentication%20method%20that,best%20fits%20your%20needs)[<sup>{14}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Option%202%3A%20Gemini%20API%20Key). En cuanto a integración con VS Code, Google proporciona *Gemini Code Assist*, una extensión/servicio para IDEs (VS Code, Android Studio, etc.) que comparte la misma “inteligencia” que Gemini CLI[<sup>{15}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=content%20generation%20and%20problem%20solving,deep%20research%20and%20task%20management)[<sup>{16}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=We%E2%80%99ve%20also%20integrated%20Gemini%20CLI,VS%20Code%20and%20Gemini%20CLI). De hecho, el *modo agente* del chat de Gemini Code Assist en VS Code está impulsado por Gemini CLI tras bambalinas, exponiendo un subconjunto de las funciones del CLI dentro del editor[<sup>{17}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20Code%20Assist%20agent%20mode)[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). Esto permite, por ejemplo, que un desarrollador inicie una tarea conversacional con Gemini en la ventana de chat de VS Code y la continúe en la terminal (o viceversa) con resultados consistentes. La extensión de VS Code habilita características como ejecutar comandos del CLI (ej. `/tools`, `/mcp`) desde la interfaz de chat, activar “modo Yolo” (ejecución automática de acciones sugeridas), realizar búsquedas web y fetch directamente, etc., sin salir del entorno de desarrollo[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). En resumen, Gemini CLI está diseñado para funcionar de la mano con VS Code, aunque también puede usarse de forma autónoma en cualquier terminal (incluso se incluye por defecto en Google Cloud Shell)[<sup>{19}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20Code%20Assist%20for%20individuals%2C,Gemini%20Code%20Assist%20agent%20mode). Es igualmente multiplataforma, funcionando donde Node.js esté disponible.

**GitHub Copilot CLI:** A diferencia de los anteriores, GitHub Copilot CLI no es una herramienta autónoma de propósito general para codificación, sino una extensión del CLI de GitHub enfocada en ayudar con comandos de terminal. Se instala como una extensión del comando `gh` (la interfaz de línea de comandos oficial de GitHub). Para instalarlo, se utiliza `gh extension install github/gh-copilot`[<sup>{20}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Copilot%20in%20the%20CLI%20is,here%20will%20be%20Windows%20PowerShell), lo cual agrega el subcomando `gh copilot` al CLI de GitHub. A partir de la versión 1.0 (marzo 2024), Copilot CLI pasó de ser una beta experimental a una extensión más madura: la versión estable más reciente es la **v1.1.1** (junio 17, 2025)[<sup>{21}</sup>](https://github.com/github/gh-copilot#:~:text=Welcome%20to%20GitHub%20Copilot%20in,21)[<sup>{22}</sup>](https://github.com/github/gh-copilot#:~:text=Releases%2013). Funciona en Windows (incluyendo PowerShell, con un script de perfil para habilitar sus alias) y en macOS/Linux (bash, zsh)[<sup>{23}</sup>](https://github.com/github/gh-copilot#:~:text=echo%20%27eval%20,%3E%3E%20~%2F.bashrc)[<sup>{24}</sup>](https://github.com/github/gh-copilot#:~:text=echo%20%27eval%20,%3E%3E%20~%2F.zshrc). En VS Code, no existe una integración gráfica específica (no instala una extensión de editor), pero se puede usar cómodamente desde la terminal integrada. De hecho, Microsoft/GitHub han demostrado su uso dentro de VS Code, permitiendo que desarrolladores obtengan sugerencias de comandos o explicaciones sin salir del editor[<sup>{25}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=GitHub%20commands)[<sup>{26}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=https%3A%2F%2Fgithub.blog%2Fwp). Al ser parte del ecosistema Copilot, requiere una suscripción o acceso válido a GitHub Copilot. Una vez instalado y autenticado (`gh copilot auth`), no hay pasos adicionales de configuración más allá de los opcionales para alias (como se detalla más adelante). En resumen, Copilot CLI es ligero de integrar: si ya usas GitHub CLI, añadirlo es inmediato. Es compatible con Windows (soporta PowerShell y Git Bash), macOS y Linux, aunque los desarrolladores notan que inicialmente tuvo un sesgo hacia entornos Unix/zsh[<sup>{27}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=Supported%20platforms) (en versiones actuales ha mejorado el soporte multiplataforma).

### Tabla: Integración y configuración en VS Code / Plataformas

| Característica | **Claude Code** (Anthropic) | **Gemini CLI** (Google) | **Copilot CLI** (GitHub) |
|----|----|----|----|
| **Instalación (CLI)** | `npm install -g @anthropic-ai/claude-code`[<sup>{28}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=1) (Node 18+) <br> Ejecutar `claude` en proyecto | `npm install -g @google/gemini-cli`[<sup>{12}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=hackable%20and%20integrable.%20,changer%20in%20this%20space) (Node 16+) <br> Ejecutar `gemini` | `gh extension install github/gh-copilot`[<sup>{20}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Copilot%20in%20the%20CLI%20is,here%20will%20be%20Windows%20PowerShell) <br> (requiere GitHub CLI) |
| **Autenticación** | API Key Anthropic (`/login` en CLI) o token org. <br> (Soporta config para Bedrock/Vertex AI)[<sup>{29}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=,Name%20of%20%2032)[<sup>{30}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=%60CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL%20%60Skip%20auto,when%20using%20an%20LLM%20gateway) | OAuth con cuenta Google (free tier 1000 req/día)[<sup>{31}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Benefits%3A)[<sup>{32}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%E2%9C%A8%20Best%20for%3A%20Developers%20who,control%20or%20paid%20tier%20access); o API Key (Studio/Vertex)[<sup>{14}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Option%202%3A%20Gemini%20API%20Key) | Cuenta GitHub con Copilot habilitado (usa credenciales de `gh` CLI ya autenticado) |
| **Extensión VS Code** | Sí – auto-instalación al ejecutar `claude` en terminal[<sup>{33}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=1,install). Botón UI y atajos (Ctrl+Esc)[<sup>{6}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=Features) | Sí – *Gemini Code Assist* (ext. oficial VS Code) usa el mismo motor[<sup>{15}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=content%20generation%20and%20problem%20solving,deep%20research%20and%20task%20management)[<sup>{17}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20Code%20Assist%20agent%20mode). Integración profunda con chat/agent mode | No ext. específica (se usa en terminal integrada). <br>Opcional: usar *Copilot Chat* aparte para ayuda en editor (no parte del CLI) |
| **Características IDE** | \- Abrir chat Claude en VSCode con atajo[<sup>{6}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=Features)<br>- Ver diffs en visor de VSCode[<sup>{34}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,from%20the%20IDE%20are)<br>- Contexto de archivo/selección automático[<sup>{35}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=instead%20of%20the%20terminal,with%20Claude%20as%20you%20work)<br>- Inserción de referencias a código rápida[<sup>{7}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=shared%20with%20Claude%20Code%20,with%20Claude%20as%20you%20work) | \- Chat de Code Assist puede invocar comandos CLI (ej. `/tools`, `/memory`)[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code)<br>- Agent mode: ejecuta planes multi-paso (escribe tests, fija errores)[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined)<br>- Búsqueda web y fetch dentro del IDE[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code) | \- Uso manual en terminal. <br>- Sugiere comandos que el desarrollador puede copiar al editor de terminal VSCode. <br>- Sin integración de diffs ni conocimiento del editor. |
| **Compatibilidad OS** | Windows, macOS, Linux (Node.js). <br>Windows soportado (incluso WSL)[<sup>{10}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Install%20%E2%80%98code%E2%80%99%20command%20in%20PATH%E2%80%9D) | Windows, macOS, Linux (Node.js). <br>Incluido en Cloud Shell (Linux)[<sup>{37}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20CLI%20and%20Gemini%20Code,Assist%20agent%20mode) | Windows, macOS, Linux. <br>Probado en Bash/Zsh; PowerShell soportado (perfil)[<sup>{38}</sup>](https://github.com/github/gh-copilot#:~:text=PowerShell) |

## Comandos y herramientas incorporados

En esta sección examinamos qué funcionalidades nativas ofrece cada asistente a través de sus comandos integrados o “herramientas” internas. Esto incluye tanto comandos de interfaz (por ejemplo, comandos de barra diagonal en Claude/Gemini CLI, o subcomandos en Copilot CLI) como las acciones que pueden efectuar autónomamente (leer/escribir archivos, ejecutar búsquedas, etc.). Cada asistente tiene un enfoque algo distinto:

- **Claude Code:** actúa como un agente conversacional dentro de la terminal. No se interactúa con él mediante subcomandos rígidos, sino con lenguaje natural, complementado por algunos comandos especiales (precedidos por `/`) para configurar o controlar el estado. Por debajo, Claude Code cuenta con un conjunto de *tools* internos que utiliza automáticamente cuando la tarea lo requiere (por ejemplo, para leer un archivo, buscar un texto, o ejecutar un comando shell)[<sup>{39}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Claude%20Code%20has%20access%20to,understand%20and%20modify%20your%20codebase)[<sup>{40}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=MultiEdit%20Performs%20multiple%20edits%20on,Creates%20or%20overwrites%20files%20Yes). Muchos de estos tools reflejan utilidades clásicas (leer/escribir archivos, listar directorios, buscar texto, ejecutar shell) que Claude invoca tras interpretar la solicitud del usuario. Existe un comando de configuración general `/config` para ver/ajustar preferencias, `/allowed-tools` para listar o limitar herramientas permitidas, `/bug` para reportar fallos, `/agents` para gestionar sub-agentes, entre otros[<sup>{41}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=To%20manage%20your%20configurations%2C%20use,the%20following%20commands)[<sup>{42}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Open%20the%20subagents%20interface). Normalmente, el flujo de uso es: el desarrollador escribe una petición en lenguaje natural (ej. “Encuentra todas las funciones sin comentarios y añade documentación”), y Claude decidirá qué acciones tomar (p. ej. usar su tool *Grep* para buscar funciones, luego *Edit* para insertar comentarios en cada archivo). En resumen, **Claude Code no requiere que el usuario memorice muchos comandos** más allá de los básicos de configuración; su fortaleza está en entender instrucciones de alto nivel y ejecutarlas mediante sus herramientas internas.

  - *Herramientas internas principales:* Claude Code dispone de herramientas como: **Read** (leer contenido de archivos), **Write** (crear/sobrescribir archivos), **Edit** (edición puntual en un archivo), **MultiEdit** (ediciones múltiples atómicas en un archivo), **LS** (listar ficheros/directorios), **Grep** (buscar patrones en contenido), **Glob** (búsqueda de archivos por patrón), **Bash** (ejecutar comandos de shell en el entorno del usuario), **WebSearch** (realizar búsquedas web con filtrado de dominios), **WebFetch** (obtener el contenido de una URL dada), **TodoWrite** (gestionar listas de tareas TODO en el código) y **Task** (para delegar a un sub-agente una tarea compleja multi-paso)[<sup>{43}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Tool%20Description%20Permission%20Required%20Bash,displays%20Jupyter%20notebook%20contents%20No)[<sup>{44}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Read%20Reads%20the%20contents%20of,Creates%20or%20overwrites%20files%20Yes). Algunas de estas herramientas, por seguridad, requieren permiso explícito del usuario antes de ejecutarse la primera vez (por ejemplo, Bash, Edit/Write que modifican el sistema o el código)[<sup>{43}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Tool%20Description%20Permission%20Required%20Bash,displays%20Jupyter%20notebook%20contents%20No). El asistente solicitará confirmación cuando una acción potencialmente peligrosa esté por realizarse, para no “volverse loco en tu sistema” sin control[<sup>{45}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=everything%20is.%20%2A%20Built,enterprise%20settings%20with%20sensitive%20code)[<sup>{46}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Task%20Runs%20a%20sub,Creates%20or%20overwrites%20files%20Yes).

  - *Comandos de configuración y control:* Además de las tools automáticas, el usuario puede interactuar con comandos como `/allowed-tools` (para listar o cambiar qué tools tiene permitido usar Claude, en caso de querer restringir ciertas acciones)[<sup>{47}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Permission%20rules%20can%20be%20configured,tools%60%20or%20in%20permission%20settings), `/config` (ajustar opciones globales o de proyecto, como por ejemplo el visor de *diff* en IDE[<sup>{48}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Alt%2BCtrl%2BK)), `/agents` (gestionar subagentes personalizados, explicado más adelante), `/help` (ver ayuda), `/login` (autenticar API key), `/bug` (enviar feedback a Anthropic) y `/exit` (salir del CLI), entre otros. También al iniciar `claude` se muestra un breve menú de opciones como iniciar un nuevo chat o revisar historial.

<!-- -->

- En síntesis, **Claude Code** está orientado a conversaciones naturales, valiéndose de su repertorio de herramientas internas para cumplir los pedidos. El usuario no escribe directamente `claude edit <file>` (no es una interfaz de comandos directos sobre archivos), sino que pide “por favor, aplica tal refactorización”, y Claude decide usar `Edit` sobre ese archivo internamente. Esto contrasta con enfoques más manuales de otras herramientas.

<!-- -->

- **Gemini CLI:** siendo igualmente un agente conversacional, ofrece una interfaz muy similar en concepto a la de Claude. Al ejecutar `gemini`, se ingresa a un REPL interactivo donde se pueden escribir solicitudes en lenguaje natural. Adicionalmente, **Gemini CLI soporta comandos de barra diagonal** para ciertas funcionalidades meta: por ejemplo, `/memory` (gestionar la “memoria” o contexto persistente del proyecto), `/stats` (ver estadísticas de uso, tokens, etc.), `/tools` (listar las herramientas disponibles y su estado), `/mcp` (gestionar servidores MCP conectados), `/help` (ayuda)[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). También cuenta con un “modo Yolo” que se puede activar, en el cual el asistente ejecutará automáticamente ciertas sugerencias (es decir, menos confirmaciones paso a paso)[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code).

<!-- -->

- Al igual que Claude, **Gemini CLI tiene numerosas herramientas incorporadas** que utiliza en un ciclo de tipo *ReAct* (razonar y actuar)[<sup>{49}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20Gemini%20command%20line%20interface,deep%20research%20and%20task%20management). Entre ellas: herramientas de sistema de archivos (lectura/escritura de ficheros, listado), comandos de terminal (ejecutar shell, similar al tool Bash de Claude), operaciones multi-archivo (posiblemente equivalentes a grep/glob), y conexión a la web (búsqueda y fetch)[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). La documentación menciona explícitamente soporte a *Web search* y *Web fetch* integrados[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code), lo que permite que Gemini consulte documentación o ejemplos en línea durante sus respuestas. Una característica destacada es la **enorme ventana de contexto** de Gemini: hasta *1 millón de tokens* en el modelo Gemini 2.5 Pro[<sup>{50}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%2A%20Free%20%26%20high,it%20in%20scripts%20for%20automation), lo que significa que puede abarcar repositorios enteros o documentación muy extensa en una sola sesión sin olvidar detalles. Esto facilita que “entienda” requerimientos largos o múltiples archivos simultáneamente.

  En su modo autónomo (*agent mode*), Gemini es capaz de elaborar **planes multi-paso** para lograr un objetivo dado por el usuario[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). Por ejemplo, ante un prompt como “Corrige los errores y escribe pruebas unitarias para este proyecto”, el agente de Gemini puede generar un plan que incluya: 1) analizar la base de código en busca de errores, 2) aplicar correcciones en múltiples archivos, 3) compilar/ejecutar pruebas para verificar, 4) generar nuevos archivos de test, iterando sobre fallos. Este modo es similar al funcionamiento interno de Claude Code, pero Gemini hace énfasis en que *se recupera de errores automáticamente* (intenta otra solución si un paso falla) y sugiere soluciones creativas si las triviales no funcionan[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined).

  En cuanto a comandos alias específicos, al ser de código abierto, Gemini CLI permite que la comunidad contribuya con **extensiones personalizadas** que actúen como comandos adicionales. Google provee por ejemplo integraciones con GitHub (acción de CLI para revisiones de PR, mencionada más adelante). Pero de fábrica, la interacción principal es vía chat. Resumiendo, **Gemini CLI** ofrece tanto la flexibilidad de diálogo natural con alto contexto, como comandos utilitarios (`/memory`, `/tools`, etc.) para inspeccionar o ajustar su estado, en una experiencia muy orientada al *power user* técnico que puede personalizar el agente.

<!-- -->

- **GitHub Copilot CLI:** este asistente funciona de manera distinta; **no es un chat generalista para codificación**, sino una herramienta puntual para ayudar con comandos de terminal y operaciones Git/GitHub. Sus comandos incorporados son básicamente dos: `gh copilot **suggest**` y `gh copilot **explain**`[<sup>{51}</sup>](https://github.com/github/gh-copilot#:~:text=Available%20Commands%3A%20alias%20%20,Suggest%20a%20command). Por diseño, *Copilot CLI* está dividido en “modos” según el tipo de comando que se necesita: cuando se usa `gh copilot suggest <descripción en lenguaje natural>`, la herramienta primero preguntará *qué tipo de comando* deseas (shell genérico, comando de Git, o comando de GitHub CLI)[<sup>{52}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Explaining%20concepts%20is%20good%20for,for%20you%20to%20choose%20from)[<sup>{53}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=The%20user%20can%20choose%20between%3A). El usuario selecciona el dominio apropiado, y luego Copilot devuelve una sugerencia de comando concreto. Por ejemplo, uno podría teclear `gh copilot suggest "listar solo archivos .jpg en subcarpetas"` y tras indicar que es un comando de shell genérico, Copilot propondrá algo como `find . -type f -name "*.jpg"` (acompañado de explicación)[<sup>{54}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Generic%20shell%20commands)[<sup>{55}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Along%20the%20way%2C%20we%20are,or%20exit%20the%20current%20question). Luego el usuario puede optar por ejecutar automáticamente ese comando sugerido, copiarlo, pedir una revisión o explicación adicional, o refinar la petición si el resultado no fue el esperado[<sup>{55}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Along%20the%20way%2C%20we%20are,or%20exit%20the%20current%20question).

<!-- -->

- El comando complementario es `gh copilot **explain** <comando>`, que sirve para obtener una explicación en lenguaje natural de lo que hace un comando existente. Por ejemplo, `gh copilot explain 'npx sirv-cli . -p 5000'` devolverá un desglose de esa instrucción, útil para entender comandos complejos o de terceros[<sup>{56}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=You%20can%20receive%20help%20from,does%2C%20I%20can%20ask%20Copilot)[<sup>{57}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=%60npx%20sirv,does%2C%20I%20can%20ask%20Copilot). Copilot CLI puede ser muy útil para desarrolladores aprendiendo comandos de Git (“¿cómo hago X en Git?”) o recordando opciones de herramientas de consola sin tener que buscar en Google, ya que aprovecha el modelo de lenguaje (basado en GPT de OpenAI) para traducir lenguaje natural a sintaxis de comandos correctamente formados[<sup>{58}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=GitHub%20Copilot%20CLI%20translates%20natural,use%20the%20following%20three%20command).

  Además de **suggest** y **explain**, la extensión ofrece `gh copilot **alias**` (que configura alias abreviados `ghcs` y `ghce` para invocar suggest/explain más rápidamente)[<sup>{59}</sup>](https://github.com/github/gh-copilot#:~:text=Is%20,and%20keeping%20them%20in%20history)[<sup>{60}</sup>](https://github.com/github/gh-copilot#:~:text=v1.0.0%20introduces%20,shell%20history%20for%20reuse%20later), y `gh copilot **config**` para opciones como activar/desactivar telemetría o la confirmación automática de ejecución[<sup>{61}</sup>](https://github.com/github/gh-copilot#:~:text=)[<sup>{62}</sup>](https://github.com/github/gh-copilot#:~:text=%24%20gh%20copilot%20config). No hay otras herramientas internas tipo “leer archivo” o “navegar web” – **Copilot CLI no tiene acceso directo al contenido de tu proyecto ni conciencia de contexto más allá de la instrucción que proporcionas**. Por ejemplo, no entiende qué archivos hay en el directorio actual a menos que se lo digas en la prompt; simplemente genera comandos plausibles. Cabe destacar que, en versiones recientes, cuando *Copilot CLI sugiere un comando, también muestra una explicación desglosada de cada parte* para ayudar al usuario a entenderla antes de ejecutarla[<sup>{63}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=,language%20to%20GitHub%20CLI%20commands). Esto añade seguridad y carácter educativo.

  En resumen, **GitHub Copilot CLI** actúa más como un *intérprete inteligente de órdenes* que como un agente autónomo: el desarrollador plantea qué quiere lograr en forma de pregunta o enunciado, y Copilot responde con el comando exacto para hacerlo (y su explicación si se desea). Siempre deja en manos del usuario la decisión final de ejecutar el comando. No edita código fuente, no lee múltiples archivos ni genera nuevos archivos de prueba automáticamente – esas son tareas fuera de su alcance, destinadas más bien al Copilot tradicional en el IDE o a asistentes como Claude/Gemini.

### Tabla: Comandos nativos y capacidades de herramienta

| **Funcionalidad / Comando** | **Claude Code** | **Gemini CLI** | **Copilot CLI** |
|----|----|----|----|
| **Interfaz principal** | Conversacional (prompt de chat interactivo). <br>Comandos `/` para config/estado (p.ej. `/config`, `/allowed-tools`, `/agents`, `/help`). | Conversacional (REPL interactivo). <br>Comandos `/` para utilidades (p.ej. `/memory`, `/tools`, `/mcp`, `/help`, modo Yolo). | Comando bajo `gh` CLI (no REPL continuo). <br>Subcomandos: `suggest <texto>` y `explain <comando>`[<sup>{51}</sup>](https://github.com/github/gh-copilot#:~:text=Available%20Commands%3A%20alias%20%20,Suggest%20a%20command). |
| **Lectura/escritura de archivos** | Sí – *tools* internos **Read/Write/Edit** para acceder y modificar código[<sup>{64}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=NotebookEdit%20Modifies%20Jupyter%20notebook%20cells,Creates%20or%20overwrites%20files%20Yes). <br>(El usuario pide en lenguaje natural; Claude decide usar estas herramientas). | Sí – herramientas integradas de **File System** (lectura/escritura)[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). <br>(Operan similar a Claude; el agente las usa según la tarea). | No – no lee archivos ni modifica código. <br>Enfocado a comandos shell, no manipula contenidos de proyecto. |
| **Ejecución de comandos shell** | Sí – herramienta **Bash** (ejecuta comandos en el entorno local)[<sup>{43}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Tool%20Description%20Permission%20Required%20Bash,displays%20Jupyter%20notebook%20contents%20No). *Requiere confirmación la 1ª vez* (por seguridad)[<sup>{43}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Tool%20Description%20Permission%20Required%20Bash,displays%20Jupyter%20notebook%20contents%20No). Puede ejecutar pruebas, scripts, etc., y devolver output. | Sí – herramienta de **terminal** integrada (similar a Bash). Puede compilar, correr linters, etc. en su loop de acciones[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). (Posible solicitar confirmación según config). | Sugiere comandos shell a partir de texto, pero **no ejecuta comandos automáticamente** salvo que el usuario confirme[<sup>{65}</sup>](https://github.com/github/gh-copilot#:~:text=%3F%20Select%20an%20option%20,Execute%20command). |
| **Búsqueda web / info externa** | Sí – **WebSearch** (búsqueda en línea con filtro de dominios) y **WebFetch** (descarga contenido URL) incorporados[<sup>{44}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Read%20Reads%20the%20contents%20of,Creates%20or%20overwrites%20files%20Yes). Deben habilitarse (con permisos) y usan API Anthropic para buscar info actual[<sup>{45}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=everything%20is.%20%2A%20Built,enterprise%20settings%20with%20sensitive%20code). | Sí – integrado con **Google Search** para obtener contexto en tiempo real[<sup>{66}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Its%20power%20comes%20from%20built,tools%20allowing%20you%20to). Puede traer documentación actual durante respuestas. (También permite *plugins* via MCP para otras fuentes). | No – sin capacidad de buscar en Internet. <br>Se basa solo en el modelo entrenado (conocimiento estático). |
| **Comprensión de contexto de código** | Sí – mantiene un mapa mental de todo el código del directorio de proyecto sin necesidad de indicar qué archivos leer[<sup>{67}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,where%20everything%20is). Gran ventana de contexto (hasta \~100K tokens con Claude 2). | Sí – contexto masivo (hasta 1M tokens) le permite cargar repositorios enteros[<sup>{50}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%2A%20Free%20%26%20high,it%20in%20scripts%20for%20automation). Usa *embedding* y MCP para manejar muchos archivos. | No – no “conoce” el proyecto, cada sugerencia es independiente. |
| **Edición/refactorización autónoma** | Sí – puede realizar refactors multiarchivo usando **MultiEdit** y otras tools. P.ej. “refactorizar para usar patrón X” y modifica donde aplique[<sup>{68}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,MultiEdit%20for%20making%20broad%20edits). Integra visor *diff* en VSCode para revisar cambios[<sup>{48}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Alt%2BCtrl%2BK). | Sí – el *agent mode* genera **planes de edición** y los ejecuta paso a paso, incluyendo multiarchivo. Recupera errores de compilación automáticamente intentando soluciones[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). | No – no edita código. Solo sugiere comandos; cualquier cambio de código debe hacerlo el desarrollador (o usar Copilot en el editor aparte). |
| **Comandos específicos extra** | `/allowed-tools`, `/config`, `/agents`, `/bug`, etc. <br>Atajos IDE (Ctrl+Esc abre chat, etc.)[<sup>{6}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=Features). | `/memory` (gestionar hechos recordados), `/stats`, `/tools`, `/mcp` (conectar servidores externos), etc.[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code). <br>Modo Yolo para auto-ejecutar pasos. | `alias` (configura alias `ghcs`/`ghce` en shell)[<sup>{59}</sup>](https://github.com/github/gh-copilot#:~:text=Is%20,and%20keeping%20them%20in%20history); `config` (toggle telemetría, confirmar ejecución por defecto, etc.)[<sup>{61}</sup>](https://github.com/github/gh-copilot#:~:text=)[<sup>{62}</sup>](https://github.com/github/gh-copilot#:~:text=%24%20gh%20copilot%20config). |
| **Explicación de comandos/código** | Sí – puede explicar por qué cierto código falla o qué hace un bloque, dentro del diálogo (usa modelo Claude para análisis). No comando dedicado, se pide en lenguaje natural (“¿qué hace esta función?”). | Sí – igualmente, se le puede preguntar dentro del chat por explicaciones de código o comandos y lo hará utilizando su modelo. | Sí – `gh copilot explain` provee explicaciones detalladas de comandos shell, git o gh CLI[<sup>{69}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Have%20GitHub%20Copilot%20explain%20computer,science%20concepts)[<sup>{57}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=%60npx%20sirv,does%2C%20I%20can%20ask%20Copilot). (No explica código fuente, solo comandos CLI). |

## Extensibilidad y acciones personalizadas (MCP, hooks, etc.)

Una consideración importante es cómo cada asistente puede extenderse más allá de sus capacidades “de fábrica”, ya sea integrándose con otras herramientas, permitiendo scripts personalizados o adaptándose a flujos específicos de un equipo. Aquí vemos diferencias marcadas en filosofía:

- **Claude Code:** si bien es un producto cerrado de Anthropic, fue diseñado para ser *personalizable dentro de ciertos límites*. No permite modificar su código fuente (no es open source), pero sí ofrece puntos de extensión:

- **Hooks personalizados:** Claude Code soporta la definición de *ganchos* (hooks) que se ejecutan antes o después de ciertas acciones internas. Por ejemplo, un desarrollador puede configurar que *después* de que Claude aplique cambios a archivos Python, se ejecute automáticamente un formateador (black) en esos archivos, o *antes* de que Claude escriba en ciertos directorios sensibles, bloquee la operación[<sup>{70}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Extending%20tools%20with%20hooks). Estos hooks se configuran mediante scripts en un directorio especial (e.j. `.claude/hooks`) y permiten integrar herramientas locales o políticas propias en el flujo de Claude.

- **Sub-agentes (agents) configurables:** como se detallará en la siguiente sección, Claude permite definir agentes secundarios en archivos Markdown (ubicados en `~/.claude/agents/` o en el repositorio bajo `.claude/agents/`) con roles específicos, que incluyen *prompts* de sistema personalizados y permisos de herramientas ajustados[<sup>{71}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Claude%20Code%20supports%20custom%20AI,Markdown%20files%20with%20YAML%20frontmatter)[<sup>{72}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Subagent%20files%20define%20specialized%20AI,subagents%20in%20the%20subagents%20documentation). Esto significa que un equipo podría crear, por ejemplo, un subagente “documentador” que solo tenga permiso de lectura y generación de markdown, con un prompt entrenado para producir documentación; Claude invocará a ese subagente automáticamente cuando detecte una tarea adecuada, o el usuario puede invocarlo explícitamente (“Usar el agente *doc-writer* para documentar el código X”). Esta capacidad extiende a Claude Code con nuevos comportamientos sin necesidad de que Anthropic los programe directamente, todo mediante configuración en Markdown[<sup>{73}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20are%20pre,Each%20subagent)[<sup>{74}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=%3E%20Use%20the%20code,to%20check%20my%20recent%20changes).

- **Protocolo MCP (Model Context Protocol):** Claude Code puede interactuar con servidores MCP externos. MCP es un protocolo emergente para permitir que diferentes herramientas de IA se comuniquen y amplíen el contexto/modelo. Por ejemplo, Anthropic documenta cómo Claude Code puede conectarse a un servidor MCP de búsqueda web para habilitar la navegación por internet[<sup>{75}</sup>](https://intuitionlabs.ai/articles/mcp-servers-claude-code-internet-search#:~:text=,Web%20Search%20MCP%20by). De hecho, *WebSearch* y *WebFetch* de Claude son internamente implementados vía MCP según algunos desarrolladores, lo que abre la puerta a que terceros implementen servidores MCP para otras funcionalidades (p.ej., un servidor MCP que provea transcripciones de YouTube, como han explorado usuarios[<sup>{76}</sup>](https://playbooks.com/mcp/power3xz-youtube-transcript#:~:text=For%20Claude%20Code,transcript%22%20%27%7B%22command)[<sup>{77}</sup>](https://playbooks.com/mcp/jkawamoto-youtube-transcript#:~:text=YouTube%20Transcripts%20MCP%20server%20for,transcript%22%20%27%7B%22command%22%3A%22uvx%22%2C%22args)). La configuración de servidores MCP externos se puede hacer vía comando `/mcp` o mediante archivos de configuración `.claude/config` o variables de entorno (`MCP_TIMEOUT`, etc. aparecen en la documentación)[<sup>{78}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=,5%20when)[<sup>{79}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=critical%20paths%20like%20flavor%20text,file%20paths%2C%20or%20bash%20commands). Esto sugiere que, aunque Anthropic no ofrece plugins oficiales más allá de WebSearch, la comunidad o la empresa pueden incorporar nuevas herramientas a Claude Code usando MCP sin tener que actualizar el cliente en sí.

- **CI/CD y GitHub integration:** Anthropic ha mencionado integración con flujos de CI; por ejemplo, se puede usar Claude Code en GitHub Actions o invocarlo en scripts para automatizar revisiones de código en los *pull requests*[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Incluso en la descripción del producto se dice que se puede “mencionar @claude en GitHub” para obtener asistencia, insinuando algún mecanismo de integración (posiblemente un GitHub App o Action oficial)[<sup>{81}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=Claude%20Code%20is%20an%20agentic,or%20tag%20%40claude%20on%20Github). De momento, la integración más directa es mediante la acción CLI: se puede ejecutar `claude` en un pipeline CI para que analice un repositorio o genere sugerencias, aunque esto requiere exponer credenciales API y cautela en entornos automatizados.

En resumen, **Claude Code** brinda extensibilidad a través de *configuraciones de alto nivel* (no modificamos su código pero sí su comportamiento). Los *subagents* en Markdown y la interfaz MCP le permiten adaptarse a casos de uso nuevos – por ejemplo, un desarrollador puede crear un subagente configurado como “analizador de seguridad” con ciertas reglas, en vez de esperar a que Anthropic incluya esa feature.

- **Gemini CLI:** al ser open source, *Gemini CLI* es intrínsecamente extensible ya que cualquier desarrollador puede bifurcar el repositorio o contribuir módulos. Pero más allá de eso, Google diseñó Gemini CLI pensando en un **ecosistema ampliable mediante estándares y archivos de configuración**:

- **Model Context Protocol (MCP):** Gemini CLI incluye soporte nativo para MCP, similar a Claude. Esto significa que se pueden conectar servidores externos que provean funcionalidad adicional o acceso a datos privados. La documentación menciona explícitamente que mediante MCP se pueden extender las capacidades con extensiones integradas o externas[<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts). Un ejemplo dado es conectar generadores de medios (Imagen, Veo para imágenes/vídeos, etc.) vía MCP[<sup>{83}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=,in%20scripts%20for%20workflow%20automation). Esto permite que, si un desarrollador quiere que Gemini realice una tarea que requiere una herramienta especializada (p. ej., generar una imagen a partir de texto, o consultar una base de datos interna), pueda ejecutar un servidor MCP que atienda esas peticiones. La configuración de servidores MCP se realiza en un JSON de settings (`~/.gemini/settings.json`) donde se definen alias tipo `@nombre` que Gemini puede invocar en las conversaciones[<sup>{84}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Using%20MCP%20Servers). Por ejemplo, se podría configurar un MCP `@database` que cuando Gemini lo llame, ejecute consultas SQL en una base interna[<sup>{85}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=custom%20tools%3A). Esta arquitectura modular es potente para integraciones corporativas.

- **Archivos de contexto personalizados (*GEMINI.md*):** Para personalizar el comportamiento en un proyecto específico, Gemini CLI soporta archivos de texto denominados `GEMINI.md` colocados en el directorio del proyecto. Este archivo permite definir *instrucciones o información persistente* que el asistente siempre considerará para ese proyecto (similar a un “sistema prompt” persistente o memoria de largo plazo). Google indica que gracias a los *custom context files (GEMINI.md)* es posible adaptar Gemini a las necesidades específicas de tu flujo de trabajo o dominio[<sup>{86}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=ideas%20github,GitHub%20repo). Por ejemplo, en `GEMINI.md` podríamos anotar convenciones de codificación del equipo, o una descripción general del proyecto y sus módulos, para que Gemini no necesite deducirlo cada vez. También es útil para que almacene “hechos” aprendidos (Gemini CLI dispone de un comando `/memory` para gestionar una memoria persistente por proyecto). Todo esto mejora la consistencia y capacidad de trabajar en tareas prolongadas.

- **Extensiones personalizadas (plugins):** Dado que es extensible y open source, ya han surgido *cheatsheets* y plugins comunitarios. La documentación oficial menciona la posibilidad de construir comandos personalizados y herramientas adicionales[<sup>{87}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%2A%20Built,Build%20your%20own%20commands)[<sup>{88}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%2A%20Multi,Build%20your%20own%20commands). Por ejemplo, un desarrollador podría añadir un nuevo comando `/todo` que integre con su gestor de tareas, o nuevas herramientas bajo el capó. Google incluso provee un *GitHub Action* para integrar Gemini CLI en flujos de GitHub (por ej., para que automáticamente haga revisión de pull requests al abrirse uno nuevo)[<sup>{89}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=GitHub%20Integration). Las *Gemini CLI GitHub Actions* permiten: comentarios automatizados con feedback en PRs, etiquetado inteligente de issues, responder a menciones `@gemini-cli` en discusiones de código, etc., configurables según la necesidad del equipo[<sup>{90}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Esto demuestra la intención de Google de que Gemini CLI no sea solo una herramienta local, sino una plataforma integrable a pipelines de desarrollo.

- **Modo no interactivo / scripting:** Por último, Gemini CLI se puede invocar de forma no interactiva con la opción `-p "<prompt>"` para usarlo en scripts[<sup>{91}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%23%20Non). Esto permite, por ejemplo, escribir un script que pase automáticamente ciertas instrucciones a Gemini CLI y obtenga resultados (se podría automatizar la generación de un informe de arquitectura con `gemini -p "Describe architecture"` y guardar la salida). También se puede limitar el análisis a ciertos directorios con flags (`--include-directories`)[<sup>{92}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=), lo cual es útil en proyectos grandes.

En suma, **Gemini CLI** sobresale en extensibilidad mediante su apertura y estándares: cualquier equipo puede customizar prompts persistentes (GEMINI.md), enchufar nuevas fuentes de información vía MCP[<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts), o incluso modificar el código. Google explicitó que invitan a la comunidad a inspeccionar, contribuir y personalizar[<sup>{93}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Because%20Gemini%20CLI%20is%20fully,ideas%20in%20our%20GitHub%20repo)[<sup>{94}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=implications,ideas%20in%20our%20GitHub%20repo). Esto lo hace muy atractivo para entornos que requieran adaptabilidad o integrar AI en sistemas existentes.

- **GitHub Copilot CLI:** este asistente es el más cerrado de los tres en términos de extensión de capacidades. Al ser esencialmente una funcionalidad específica dentro del CLI de GitHub, **no ofrece oficialmente un mecanismo de plugins o personalización profunda**. Algunas consideraciones:

- No soporta MCP ni ninguna forma de agregar nuevos dominios de comando más allá de los tres que ya maneja (shell genérico, git, gh CLI).

- No tiene archivos de configuración donde uno pueda enseñarle conocimientos de entorno. Su “contexto” es únicamente la petición dada en cada uso, y la base de conocimiento del modelo de IA de Copilot (que no es modificable por el usuario).

- La “extensibilidad” se limita a confort: se pueden configurar alias de shell (como `??` en lugar de `gh copilot suggest`, que es la funcionalidad original en la beta previa)[<sup>{95}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=You%20can%20run%20GitHub%20Copilot,them%2C%20run%20the%20following%20command), o ajustar si queremos que al ejecutar un comando sugerido luego de confirmar este se guarde en el *history* de la terminal (por defecto, usando los alias `ghcs`/`ghce`, el comando ejecutado **sí** se añade al historial para referencia futura)[<sup>{59}</sup>](https://github.com/github/gh-copilot#:~:text=Is%20,and%20keeping%20them%20in%20history)[<sup>{96}</sup>](https://github.com/github/gh-copilot#:~:text=explain,shell%20history%20for%20reuse%20later). También se puede decidir si requerir confirmación cada vez que se ejecuta un comando sugerido o permitir ejecución directa (configurable vía `gh copilot config` interactivo)[<sup>{97}</sup>](https://github.com/github/gh-copilot#:~:text=)[<sup>{98}</sup>](https://github.com/github/gh-copilot#:~:text=For%20more%20information%2C%20run%20,help).

- En entornos avanzados, un usuario podría escribir scripts externos que llamen a Copilot CLI (por ejemplo, un script Python que invoque `gh copilot suggest "do X"` y capture la salida para procesarla). Pero esto no es un uso intensamente documentado, y estaría limitado por la naturaleza de consulta/respuesta de la herramienta.

Hay que señalar que, dado que GitHub Copilot CLI está centrado en terminal, GitHub ha enfocado otras áreas de extensibilidad en productos hermanos: por ejemplo, *Copilot para Pull Requests* (integrado en GitHub.com para sugerir descripciones de PR o revisar código) y *Copilot Chat* (que sí tiene cierta capacidad de consultar la base de código abierta en el editor). Sin embargo, esas no son extensiones de Copilot CLI sino funcionalidades separadas de la familia Copilot.

En conclusión, **Copilot CLI** es bastante limitado en extensibilidad: fue hecho para una tarea concreta y lo cumple dentro de su ámbito. Los usuarios avanzados que buscaban ampliar su alcance han notado esa carencia (incluso en foros se comenta que “la CLI oficial de Copilot es muy básica” en comparación con competidores, y buscan otras opciones más flexibles)[<sup>{99}</sup>](https://www.reddit.com/r/commandline/comments/1doj06s/the_official_github_copilot_cli_is_really_bad/#:~:text=The%20official%20GitHub%20Copilot%20Cli,set%20up%20and%20straightforward%20use). Por supuesto, la ventaja es que, al ser simple, no requiere mucho mantenimiento de configuración – funciona out-of-the-box siempre que el servicio de Copilot esté activo.

### Tabla: Extensibilidad y configuración avanzada

| **Aspecto de extensibilidad** | **Claude Code** | **Gemini CLI** | **GitHub Copilot CLI** |
|----|----|----|----|
| **Protocolos estándar (MCP)** | Sí – soporta *Model Context Protocol* para herramientas externas. Ej: *WebSearch* implementado vía MCP[<sup>{75}</sup>](https://intuitionlabs.ai/articles/mcp-servers-claude-code-internet-search#:~:text=,Web%20Search%20MCP%20by). Permite añadir servidores MCP propios (mediante `/mcp add` o config JSON) para nuevas capacidades (transcripción, búsquedas especializadas, etc.)[<sup>{76}</sup>](https://playbooks.com/mcp/power3xz-youtube-transcript#:~:text=For%20Claude%20Code,transcript%22%20%27%7B%22command)[<sup>{77}</sup>](https://playbooks.com/mcp/jkawamoto-youtube-transcript#:~:text=YouTube%20Transcripts%20MCP%20server%20for,transcript%22%20%27%7B%22command%22%3A%22uvx%22%2C%22args). | Sí – soporte MCP nativo[<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts). Permite conectar servidores externos (plugins) para ampliar funciones (ej: llamados a APIs, generadores multimedia[<sup>{83}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=,in%20scripts%20for%20workflow%20automation)). Config en `settings.json` con alias `@` invocables desde chat[<sup>{84}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Using%20MCP%20Servers). | No – no hay soporte de protocolos de extensión. No puede usar herramientas externas ni conectarse a servicios adicionales (más allá de la API de Copilot). |
| **Archivos config. Markdown** | Sí – permite *sub-agents* definidos en archivos Markdown con YAML (en `.claude/agents/`)[<sup>{71}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Claude%20Code%20supports%20custom%20AI,Markdown%20files%20with%20YAML%20frontmatter)[<sup>{100}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=File%20locations). Además, `settings.json` para variables/flags config (ej: habilitar Bedrock/Vertex, timeouts, etc.)[<sup>{101}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Variable%20Purpose%20,Name%20of%20%2032)[<sup>{102}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=,critical%20paths%20like%20flavor%20text). | Sí – soporta archivo **GEMINI.md** en proyectos para contexto permanente e instrucciones personalizadas[<sup>{86}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=ideas%20github,GitHub%20repo). Usa también `~/.gemini/` para settings globales. Facilita “memoria” persistente y adaptación a cada proyecto. | No – no utiliza archivos de configuración de usuario para personalizar comportamiento. Solo conserva ajustes mediante `gh copilot config` interactivamente (telemetría, confirmación ejecución, etc.) en la CLI. |
| **Definición de comandos/acciones custom** | Limitada – no se pueden crear nuevos comandos `/` arbitrarios (más que los previstos). Pero sí **hooks** para ejecutar acciones locales pre/post tools[<sup>{70}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Extending%20tools%20with%20hooks). Y subagentes que actúan como “acciones” especializadas cuando se invocan por nombre[<sup>{42}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Open%20the%20subagents%20interface)[<sup>{74}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=%3E%20Use%20the%20code,to%20check%20my%20recent%20changes). | Sí – estructura de código abierto y guía para **Custom Extensions**[<sup>{87}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%2A%20Built,Build%20your%20own%20commands). Se pueden añadir comandos slash propios o integrar Gemini en otras apps (Google provee Action para GitHub[<sup>{89}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=GitHub%20Integration)). Comunidad puede contribuir nuevas features directamente al repo[<sup>{93}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Because%20Gemini%20CLI%20is%20fully,ideas%20in%20our%20GitHub%20repo). | No – no es extensible en cuanto a nuevos subcomandos. Los alias ofrecidos (`ghcs`, `ghce`) son atajos, no funcionalidades nuevas[<sup>{59}</sup>](https://github.com/github/gh-copilot#:~:text=Is%20,and%20keeping%20them%20in%20history). |
| **Integración CI/CD u otras apps** | Sí – pensado para integrarse con flujos de DevOps: puede usarse en CI (ej. automatizar PRs con Claude)[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Anthropic ofrece acción de GitHub (`anthropics/claude-code` en Marketplace) para análisis en PRs[<sup>{81}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=Claude%20Code%20is%20an%20agentic,or%20tag%20%40claude%20on%20Github). | Sí – *Gemini CLI GitHub Action* oficial para PRs, issues, etc.[<sup>{103}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Puede ejecutarse en scripts no interactivos (`gemini -p ...`) para tareas automatizadas[<sup>{91}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%23%20Non). Se integra con Google Cloud services (Cloud Shell, Vertex AI). | Parcial – no hay integración oficial con CI. Sin embargo, al ser CLI, usuarios pueden llamarlo en scripts (ej: generar comando deployment on-the-fly). No diseñado para proveer análisis completo en PRs (esa tarea la cubre Copilot for PR, separadamente). |
| **Open source / modificabilidad** | No (código cerrado). SDK disponible para construir aplicaciones encima, pero core cerrado. | Sí – 100% código abierto (Apache 2.0)[<sup>{93}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Because%20Gemini%20CLI%20is%20fully,ideas%20in%20our%20GitHub%20repo). Se puede *forkear*, auditar y extender libremente. Google espera contribuciones de la comunidad[<sup>{94}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=implications,ideas%20in%20our%20GitHub%20repo). | No – código cerrado (parte de GitHub CLI). En beta fue fuente cerrada distribuida via npm. Usuarios no pueden modificar su funcionamiento interno. |

## Sub-agentes especializados (agentes secundarios)

Una de las capacidades avanzadas solicitadas es la generación de **sub-agentes especializados**: es decir, instancias de los asistentes enfocadas en tareas específicas (revisión de código, generación de tests, análisis de requisitos, etc.), con configuraciones o permisos distintos, que puedan trabajar en conjunto con el asistente principal. Este concepto aparece en mayor o menor medida en Claude Code y Gemini CLI, mientras que en Copilot CLI no aplica.

- **Claude Code:** como vimos, Claude soporta sub-agentes configurables. ¿Cómo funciona? Esencialmente, cada sub-agente es un archivo Markdown (por ejemplo `code-reviewer.md`) con una cabecera YAML que define su nombre, descripción de cuándo debe usarse, y qué herramientas tiene permitidas[<sup>{104}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure)[<sup>{105}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields). El cuerpo del Markdown contiene un prompt de sistema extenso que configura la personalidad y objetivo del sub-agente (por ejemplo, “Eres un revisor de código experto en limpieza de estilo. Solo tienes permiso de lectura, no modifiques código. Tu tarea es analizar cambios recientes y comentar mejoras.”). Una vez definido, Claude Code **puede invocar automáticamente al sub-agente** cuando detecta una solicitud que encaja en su descripción, o el usuario puede pedir explícitamente su uso[<sup>{106}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior)[<sup>{107}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=%3E%20Use%20the%20code,to%20check%20my%20recent%20changes). Cada sub-agente corre con un contexto separado del agente principal, lo que preserva el enfoque: por ejemplo, el sub-agente revisor puede cargar solo el diff reciente y sus instrucciones especiales, sin contaminar la conversación principal[<sup>{108}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Context%20preservation). Esto mejora la calidad de las respuestas en tareas especializadas y permite aislar preocupaciones (context preservation). Claude trae incluso un comando interactivo `/agents` que asiste al usuario a crear nuevos sub-agentes paso a paso (ofreciendo plantillas, lista de herramientas disponibles para asignar, etc.)[<sup>{109}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=1)[<sup>{110}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Select%20%27Create%20New%20Agent%27).

  De fábrica, Claude Code no viene con decenas de sub-agentes predefinidos, pero sí proporciona esta **infraestructura para que los usuarios o empresas configuren los suyos**. En la documentación se sugieren algunos comunes: *code-reviewer*, *test-writer*, *doc-generator*, etc., que cada uno podría tener diferente combinación de permisos y enfoque. Por ejemplo, un sub-agente de generación de pruebas unitarias podría tener permiso de escritura de archivos pero solo en el directorio `tests/`, y contener un prompt que le indique que genere tests basados en las funciones encontradas en cierto módulo. Mientras, un sub-agente analizador de requerimientos podría no necesitar ninguna tool excepto lectura, pero tener un prompt con técnicas de verificación de consistencia. Claude delegará a estos sub-agentes cuando corresponda, aumentando la tasa de éxito en tareas complejas[<sup>{111}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20can%20be%20fine,success%20rates%20on%20designated%20tasks).

  En síntesis, **Claude Code incorpora un potente mecanismo multi-agente**, aunque depende de la configuración manual para explotar su potencial al máximo. Esto refleja la ambición de Anthropic de que Claude actúe como un “ingeniero par” capaz de dividir tareas: *un ingeniero principal orquestando varios asistentes expertos.* Cabe aclarar que la capacidad de sub-agentes apareció a mediados de 2023 y se ha ido robusteciendo; es algo relativamente único de Claude Code (entre las herramientas comerciales de IA para código).

- **Gemini CLI:** en el momento de su lanzamiento, Gemini CLI no presentaba explícitamente un sistema de sub-agentes configurables por el usuario *dentro* del mismo proceso (como sí lo tiene Claude). Sin embargo, su **enfoque multi-paso y integraciones permite lograr resultados similares**. En lugar de sub-agentes internos, Gemini propone integraciones externas (por ejemplo, el Qodo Gen CLI, mencionado en el blog de Prompt Security, es una herramienta separada que permite crear agentes a medida y podría interactuar con Gemini)[<sup>{112}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Qodo%20Gen%20CLI%20,tailored%20to%20your%20project%27s%20needs)[<sup>{113}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=improvements%2C%20a%20test%20generation%20agent,agnostic.%20It).

  No obstante, no se menciona que Gemini CLI en sí cree “hilos secundarios” con diferentes roles. Su agente principal sí ejecuta múltiples pasos, pero todos guiados por la misma personalidad central y el mismo contexto de conversación, ajustando su estrategia sobre la marcha en base a errores o nuevos objetivos[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). Es posible que en futuras versiones Google introduzca plantillas de agente (dado que es un área de interés general), o que recomiende usar la vía de *MCP servers* para lograrlo (por ejemplo, un servidor MCP podría ser un “agente de code review” al que Gemini llama cuando necesita feedback de estilo, etc.).

  Por ahora, lo más cercano dentro de Gemini CLI es el mencionado archivo GEMINI.md, donde uno podría pre-definir secciones con contexto o instrucciones para ciertos tipos de tareas, pero no es exactamente un sub-agente separado, sino más bien *contexto pre-configurado*.

  Un punto relacionado: Google sí ofrece ya agentes especializados pero como servicios aparte, e.g. Codey (modelo de PaLM 2 enfocado a código) en Vertex AI, etc., pero en Gemini CLI específicamente todo está unificado bajo el modelo Gemini 2.5 Pro en la versión actual.

  En resumen, **Gemini CLI no provee sub-agentes personalizables como entidad separada**, aunque su gran contexto y la integración con flujos (como GitHub Action para code review, etc.) le permiten encargarse de tareas específicas de forma secuencial. Es más “un agente para gobernarlos a todos” (al menos de momento).

- **GitHub Copilot CLI:** no soporta ni necesita sub-agentes. Su propósito estrecho (comandos CLI) no requiere especialización de roles – de hecho el modelo de lenguaje subyacente (derivado de GPT-3.5/4 de OpenAI adaptado a Copilot) maneja todo internamente. Para tareas más allá de sugerir comandos, GitHub ofrece productos diferenciados (Copilot Chat para conversar sobre código, etc.). En este contexto, no hay sub-agentes ni configuración alguna relativa a esto en Copilot CLI.

## Casos de uso y capacidades en escenarios prácticos

Por último, evaluaremos cómo cada asistente puede ayudar en los **casos de uso específicos** que nos interesan, asumiendo un entorno de desarrollo de software típico (proyecto con repositorio Git, requerimientos definidos, etc.). Los escenarios son:

1. **Análisis de requerimientos** – detectar inconsistencias, requisitos faltantes, o sugerir mejores prácticas a partir de documentación de requisitos.
2. **Generación de funcionalidad a partir de requerimientos** – producir código nuevo conforme a una especificación o historia de usuario dada.
3. **Revisión de código (estándares y buenas prácticas)** – analizar código existente o cambios propuestos y compararlos contra guías de estilo, patrones recomendados, posible presencia de *code smells*, etc.
4. **Depuración (debug) de código** – ayudar a identificar la causa de errores en tiempo de ejecución o lógicos, potencialmente ejecutando el código o pruebas.
5. **Generación de pruebas unitarias** basadas en requerimientos y especificaciones – crear casos de prueba automáticos para validar que el código cumple con lo solicitado.
6. **Refactorización de código según nuevos requisitos** – modificar código existente para adaptarlo a un cambio en requerimientos, manteniendo la coherencia.
7. **Análisis de cambios (diff) en un commit de Git** – explicar qué cambió, por qué pudo haberse hecho, si introduce problemas, etc.
8. **Gestión de solicitudes de cambio en requisitos** – redacción estructurada de modificaciones a documentos de requerimientos o especificaciones cuando hay cambios solicitados.

A continuación, se discute la aptitud de Claude Code, Gemini CLI y Copilot CLI en cada uno de estos puntos:

### 1. Análisis de requerimientos

*Claude Code* puede cargar documentos largos (e.g. especificaciones en Markdown o PDF convertidos a texto) usando su amplio contexto y herramientas de lectura. Un usuario podría pegar o referenciar un documento de requisitos y pedir a Claude que lo analice. Dado que Claude mantiene *awareness* del proyecto completo[<sup>{67}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,where%20everything%20is), es capaz de correlacionar requerimientos con la implementación existente para detectar, por ejemplo, que alguna característica no está implementada o hay requerimientos conflictivos con la arquitectura actual. No existe un comando automático “find contradictions”, pero sí se le puede preguntar directamente: “¿Encuentras requisitos contradictorios o ambiguos en este documento?” y Claude brindará un análisis razonado, apoyado en su comprensión del lenguaje natural. Claude destaca por su capacidad de comprender contextos muy amplios de manera coherente (modelo Claude 2 con \>100k tokens). Además, si se configura un sub-agente de tipo “analista” con un prompt especializado en ver consistencia, Claude podría delegarle esta tarea para mayor precisión. En general, **Claude Code ofrece una buena asistencia en análisis de documentos de requisitos** gracias a su fuerte comprensión del lenguaje y posibilidad de ingestar documentación entera.

*Gemini CLI*, con su enorme ventana de 1M de tokens, puede incluso cargar varios documentos de requisitos completos simultáneamente. Su integración con Google Search podría ser útil para buscar definiciones externas o referencias si los requerimientos mencionan estándares. En la práctica, un desarrollador podría copiar el texto del requerimiento en la sesión Gemini y preguntarle por inconsistencias. Gemini 2.5 es un modelo muy capaz en lenguaje natural, por lo que identificar elementos faltantes o inconsistentes en la descripción de funcionalidades entra dentro de su capacidad. No hay evidencia de un flujo automatizado específico para esto, pero combinando **GEMINI.md** (se podría colocar ahí la visión general del producto y requerimientos clave para que siempre los considere) con las capacidades de diálogo, **Gemini CLI sería igualmente eficaz señalando posibles contradicciones o requisitos implícitos que falten**. Por ejemplo, se le podría pedir: “Revisa estos user stories y dime si alguno asume funcionalidad no especificada explícitamente”, y aprovechará su razonamiento para responder.

*Copilot CLI* no es adecuado para este caso. Al no ser un agente de comprensión de lenguaje general sino un ayudante para comandos, no le podemos dar un documento de texto y esperar un análisis. Para análisis de requerimientos, GitHub propondría usar Copilot Chat (en VS Code) o simplemente consultar a ChatGPT. En conclusión, **Copilot CLI no cubre este escenario**.

### 2. Generación de código basado en requerimientos

*Claude Code* brilla en la generación de código autónoma. Uno puede describirle una nueva funcionalidad, incluso vagamente, y Claude puede crear múltiples archivos, funciones y módulos necesarios. Por ejemplo, se ha demostrado que Claude Code puede “mapear y explicar bases de código enteras en segundos” y luego *“ayudar a convertir ideas en código”*[<sup>{114}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Claude%20Code%3A%20Anthropic%27s%20AI%20Pair,Programmer%20in%20the%20Terminal). Si se le proporciona un requerimiento (ej: *“Necesito una API REST para gestionar inventarios con autenticación y logs”*), Claude podría planificar la estructura (crear archivos de rutas, controlador, modelo) y escribir el código correspondiente, ejecutando pruebas unitarias después para verificar. Su capacidad de comprender lenguaje natural extenso le ayuda a adherirse a la especificación dada. Además, como conoce el contexto del proyecto, integrará la nueva funcionalidad respetando el estilo y estructura existente. Vale notar que conviene validar siempre la salida y probablemente guiarlo en iteraciones (Claude puede preguntar aclaraciones si algo es ambiguo). **Claude Code, en resumen, puede generar código nuevo a partir de especificaciones textuales de forma muy completa**, actuando como un desarrollador que implementa un requerimiento paso a paso y hasta haciendo commit de los cambios (si se lo indica). De hecho, puede abrir una rama, aplicar cambios y hasta proponer un mensaje de commit (aunque esto último hay que hacerlo con comandos git externos o integraciones CI, ya que su focus es editar archivos y ejecutar tests).

*Gemini CLI* tiene objetivos similares. En su anuncio, Google destacó que Gemini CLI “excel at coding” pero también se construyó para “much more: content generation, problem solving, task management”[<sup>{115}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20CLI%20is%20here%20to,AI%20key%20for%20more%20access)[<sup>{116}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=power%20to%20your%20command%20line,offering%20AI%20help%20in%20both). Es decir, **Gemini CLI es capaz tanto de generar código como de generar otros contenidos**. Dado un requerimiento, el agente puede desglosarlo en tareas (gracias a su agente interno) y escribir el código correspondiente. Una ventaja es su coherencia entre VS Code y CLI: podríamos iniciar una conversación en el chat del editor describiendo la especificación, Gemini comienza a generar código en el entorno IDE (quizá creando un archivo nuevo), y en paralelo en la CLI podríamos ejecutar `gemini` para monitorear o complementar la tarea. Con su enorme contexto, podría incluso cargar documentos de diseño (en texto) junto al requerimiento para asegurarse de cumplirlos. Google menciona que Code Assist (impulsado por Gemini CLI) puede “iterar, aprender y superar problemas rápidamente”[<sup>{117}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Sometimes%2C%20an%20IDE%20is%20the,learn%20and%20overcome%20issues%20quickly). Un ejemplo dado: *“coloca cualquier prompt en la ventana de chat en modo agente, y Code Assist escribirá tests, corregirá errores, construirá funcionalidades o incluso migrará tu código”*[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). Esto aplica directamente a coger un requerimiento (“migrar mi app de framework X a Y”) y hacer gran parte del trabajo automáticamente. **Gemini CLI por tanto es muy fuerte en generación de código** conforme a requerimientos, con la salvedad de que es un producto relativamente nuevo y la calidad de la salida dependerá de la claridad del prompt y la madurez del modelo (Gemini 2.5 Pro es competitivo con GPT-4 en muchos sentidos, así que se espera una alta calidad).

*Copilot CLI* nuevamente no es la herramienta para esto. No genera código fuente; a lo sumo podría ayudarnos a ejecutar algún generador (por ejemplo, sugerir el comando de *Angular CLI* correcto para crear un componente una vez que decidimos hacerlo). Pero la redacción de lógica de negocio o estructuras de datos no entra en su domain. Para generación de código, GitHub Copilot **en el editor** (Copilot “normal”) sí es apropiado, pero la interfaz CLI no.

### 3.Revisión de estándares y buenas prácticas de codificación

*Claude Code* puede actuar como revisor automatizado. Puede leer tu base de código (tiene la tool *Read* y entendimiento global) y se le puede pedir “revisa si seguimos las guías de estilo PEP8 en este módulo” o “encuentra posibles malas prácticas de concurrencia en este proyecto”. Dado que su modelo (Claude) es muy conversacional e instruido en principios éticos y de programación, suele dar consejos de buena calidad en materia de estilo y mejores prácticas. Un enfoque práctico es usar un sub-agente “linter” con un prompt especializado para esto; por ejemplo, un agente que recorra el código y señale code smells conocidos (variables globales no deseadas, funciones demasiado largas, etc.). De hecho, Anthropic integró Claude Code con CI pipelines, por lo que un caso de uso es **automatizar revisiones de código** en cada pull request[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Claude Code puede generar un *diff* con sugerencias o comentarios, o incluso corregir directamente algunos problemas. Un desarrollador mencionó que Claude es bueno sugiriendo mejoras de legibilidad y organización del código, actuando como un “senior dev” que guía. En conclusión, **Claude Code es apto para tareas de revisión estática de código y cumplimiento de estándares**, aunque conviene acotar el scope (p.ej., revisar módulo por módulo) para no abrumar su contexto.

*Gemini CLI* también se orienta a esto, y de hecho Google proporciona desde el día uno una *GitHub Action de Code Review* usando Gemini[<sup>{103}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Esto sugiere que Gemini CLI viene con cierto entrenamiento o ejemplos enfocados en revisar PRs, detectar issues comunes y proponer mejoras. Su conexión a la web podría incluso buscar en la documentación oficial de un framework cuando ve un patrón sospechoso, para fundamentar una recomendación. Por ejemplo, en un PR en GitHub, `@gemini-cli` puede ser mencionado y automáticamente responderá con un análisis del cambio, puntos de atención y recomendaciones[<sup>{90}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Con la personalización, un equipo podría configurar *GEMINI.md* con sus normas de estilo para que siempre las tenga en cuenta. **Gemini CLI, por tanto, ofrece una fuerte capacidad de revisión de código**, facilitada por su integración con la plataforma de repositorios y su conocimiento actualizado (vía web) de las mejores prácticas.

*Copilot CLI* no realiza revisiones de código. No tiene forma de “leer” un conjunto de cambios y opinar al respecto. Nuevamente, esa labor recae en Copilot en el editor (la extensión Copilot Chat en VS Code *sí* puede resumir diffs o comentar PRs en GitHub para usuarios Enterprise). Pero Copilot CLI como tal no es para análisis de código.

### 4. Ejecución de debug en código construido

Este caso es interesante porque implica correr el programa o sus pruebas para detectar errores. *Claude Code* puede ayudar en la depuración de varias formas. Primero, puede examinar mentalmente el código en busca de errores lógicos, si se le describe un síntoma. Pero más aún, con su herramienta **Bash** puede ejecutar el código o comando de pruebas. Por ejemplo, si el proyecto tiene un suite de tests, uno puede decir “ejecuta los tests” y Claude hará algo como `pytest` (pidiendo permiso para ejecutar en shell)[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Al obtener el resultado (por ejemplo, tests fallando, con *tracebacks*), Claude los leerá y los incluirá en su contexto (porque captura la salida del comando) y podrá razonar sobre la causa del fallo. Luego, usando su herramienta de edición, podría intentar corregir el código. Este ciclo implementa un *debugger AI* rudimentario: ejecuta, observa fallos, propone parches, vuelve a ejecutar. De hecho, en pruebas de usuarios, Claude Code ha sido capaz de **localizar la causa de excepciones y arreglarlas autónomamente**. Sus limitaciones podrían estar en problemas muy profundos que requieran múltiples ejecuciones o interactividad (no puede abrir un verdadero depurador con breakpoints interactivos, solo ejecutar programas y analizar texto de salida). Pero para la mayoría de debugging sincrónico, es muy útil. Además, su sub-agente *Task* puede orquestar multi-pasos, lo que imagino es utilizado precisamente en secuencias de debug (similar a cómo GPT-4 en herramientas tipo “OpenAI function calling” manejaría ejecutar, leer output, etc.). En resumen, **Claude Code puede encargarse de una sesión de debugging básica**: correr la app/pruebas, detectar errores, sugerir correcciones y validarlas al volver a correr.

*Gemini CLI* asimismo puede ejecutar comandos (compilar, correr tests) y reaccionar a los resultados. En su blog, Google presumió que Code Assist *“auto-recupera caminos de implementación fallidos”*[<sup>{118}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=agent%20mode%2C%20and%20Code%20Assist,may%20not%20have%20even%20imagined), lo que implica que si su primer intento de código tiene un bug, detectará el error (sea de compilación o test) y probará otra solución sin que se le indique explícitamente. Esto es valioso en depuración: *Gemini CLI podría compilar tu proyecto, ver el error, e iterar hasta que compile limpiamente.* Para errores lógicos, quizás necesitará más guía, pero su contexto grande le permite cargar logs extensos o stack traces enormes y analizarlos. Y gracias a la integración web, si el error proviene de una librería, podría buscar en StackOverflow una pista. Por ejemplo, imagina que ocurre una excepción desconocida de una API externa – Gemini podría invocar la búsqueda web para ver si alguien tuvo ese error y cómo se resolvió[<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts)[<sup>{119}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,workflows%20by%20invoking%20Gemini%20CLI). Esta es una diferenciación importante: **Gemini CLI es “internet-aware” y puede usar esa ventaja en debugging complejo en tiempo real**, donde quizás la solución está documentada en línea.

*Copilot CLI* no ejecuta código. Lo más que haría es, a pedido del usuario, sugerir cómo invocar un depurador (ej. “¿cómo ejecuto `gdb` con este binario?”). Pero el proceso de debugging asistido no entra en su alcance.

### 5. Generación de pruebas unitarias basadas en requerimientos

*Claude Code* puede generar tests automáticamente. Si se le indica “crea pruebas unitarias para asegurar que la implementación cumple con X”, puede usar su conocimiento del código y la descripción X para escribir archivos de prueba. Incluso tiene la herramienta **Write** para crear nuevos archivos. Un caso típico: tras implementar una funcionalidad, pedirle “por favor, genera casos de prueba para esta función con escenario A, B, C”. Claude escribirá los tests (pudiendo consultar el código fuente de la función en cuestión, que conoce por contexto) y luego puede ejecutarlos para confirmar que pasan. Si algunos fallan porque la implementación estaba incompleta, el ciclo de depuración de antes entra en juego. Vale mencionar que, dado que generará texto (código de test) a partir de una intención en lenguaje natural, el desarrollador debe revisar que los tests realmente reflejen los requerimientos (pero esto es similar a revisar tests escritos por un junior dev, por ejemplo). Con sub-agentes, se podría tener un agente “tester” que siempre escriba casos paramétricos, etc. **Claude Code, en definitiva, agiliza la creación de suites de prueba**, algo confirmado por usuarios que reportan mayor cobertura de tests con menos esfuerzo.

*Gemini CLI* igualmente tiene muy claro este uso. En la presentación de Code Assist se recalca “...el agente escribirá tests, corregirá errores...”[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). De hecho, al usar el modo agente en VS Code tras implementar una funcionalidad, suele sugerir automáticamente generación de tests como parte de completar la tarea. Un punto fuerte es que Gemini, si tiene acceso a los requerimientos (por ejemplo, se los dimos en el prompt inicial), puede verificar que cada requisito tenga un caso de prueba asociado. Con 1M tokens, podría cargar *todo* el documento de especificación y generar un archivo de pruebas por cada enunciado verificable. Esta es una capacidad sin precedentes en asistentes anteriores, que estaban limitados por contexto. Además, Google proporciona *agents preconstruidos* en Qodo Gen CLI (una herramienta relacionada) como un “test generation agent”[<sup>{120}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=say%2C%20monitors%20your%20repo%20for,For%20advanced%20cases%2C%20you%20can), lo que sugiere que la necesidad fue identificada. Aunque Qodo es aparte, podría integrarse con Gemini (de hecho Qodo permite usar modelos GPT o Claude, pero también podría usar Gemini si configurado). Centrándonos en Gemini CLI puro, **este puede generar casos de prueba exhaustivos**, y su conocimiento actualizado podría incluir las últimas recomendaciones de frameworks de testing (por ejemplo, tests de propiedad con Hypothesis, etc., si corresponde).

*Copilot CLI* no genera tests, salvo que uno ya sepa que quiere usar una herramienta CLI para generarlos (como *rails generate test* etc., que Copilot CLI podría sugerir el comando). En general, no aplica.

### 6. Re-factorización de código basado en requisitos cambiantes

*Claude Code* fue prácticamente hecho para refactorizar con contexto global. Puedes decirle “Tenemos que cambiar la forma en que calculamos los impuestos según el nuevo requisito X; aplica los cambios necesarios en el código” y Claude localiza todas las partes relevantes en la base de código y las modifica consecuentemente. Su herramienta **MultiEdit** le permite realizar cambios sincronizados en varios archivos manteniendo consistencia[<sup>{121}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Grep%20Searches%20for%20patterns%20in,from%20a%20specified%20URL%20Yes). Por ejemplo, renombrar una clase usada en 20 archivos se hace de forma segura con MultiEdit (todas las modificaciones en lote o ninguna, para evitar estados intermedios incoherentes). Claude también puede proporcionar un resumen de los cambios (a veces reporta en la conversación qué hizo en cada archivo). Dado que comprende la intención de la refactorización (no solo la sintaxis), es más fiable para cambios amplios que un simple *search & replace*. En casos de requisitos nuevos, puede combinar generación de código nuevo con adaptación del existente. Por ejemplo, “ahora nuestro sistema debe soportar múltiples monedas” – Claude puede refactorizar funciones financieras para aceptar moneda como parámetro, actualizar tests, etc. Con su “conciencia de proyecto entero”[<sup>{67}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,where%20everything%20is), **Claude Code sobresale en refactoring a gran escala** comparado con asistentes integrados a un solo archivo.

*Gemini CLI* del mismo modo maneja refactors multiarchivo. En su modo agente, si le dices “migra nuestro código de usar API v1 a API v2”, elaborará un plan: identificar dónde se usa la API v1 en todo el repo (usando grep interno), luego editar cada lugar para ajustarlo a API v2, y finalmente correr la app o tests para verificar nada roto. Su integración con VS Code permite mostrar al usuario los diffs de esos cambios para aprobación (de forma similar a Claude). Un detalle es que Gemini CLI, al ser open source, podría integrar herramientas estáticas externas para verificar el refactor (por ejemplo, correr un linter específico después de los cambios). Y su web access puede buscar si la API v2 tiene guías oficiales de migración y seguirlas[<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts). Así, **Gemini CLI es muy competente en refactorización guiada por requerimientos**. Google incluso menciona “migrar tu código” como uno de los casos de uso manejados[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined).

*Copilot CLI* no realiza refactors. Solo podría ayudar a ejecutar una búsqueda grep (por ejemplo, `gh copilot suggest "find references to X"` → devuelve un comando `grep -R "X"`), pero el proceso de modificar código no está en su alcance.

### 7. Análisis de cambios en un commit (Git diff)

*Claude Code* puede recibir un diff (por ejemplo, con su herramienta Read podría abrir la salida de `git diff` o `git show <commit>`) y comentarlo. Como entiende el contexto del proyecto, puede explicar qué hace ese commit, si introduce posibles bugs o si cumple con los requisitos relacionados. De hecho, este es un caso de uso que varias empresas quieren: asistentes que automaticen *code reviews*. Claude Code integrándose en GitHub Actions puede leer cada PR y generar comentarios de revisión[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Un commit aislado también puede ser analizado en la sesión de chat: “Aquí está el diff de la última entrega, ¿qué hace y está todo bien?”. Claude resumirá los cambios y potencialmente señalará efectos colaterales. Con un sub-agente “code-reviewer” (como ilustramos antes), esto se vuelve aún más enfocado. **Claude, por tanto, es muy útil para revisar commits y PRs**, actuando como un par de ojos extra.

*Gemini CLI* ya provee esa funcionalidad mediante su GitHub Action: en cada PR puede proporcionar *contextual feedback and suggestions*[<sup>{103}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Podemos esperar que Gemini sea capaz de determinar si un commit cumple con la descripción del issue original, o si hay omisiones (ej: “este commit dice que agrega validación X pero no veo tests correspondientes, ¿debería agregarlos?”). Su memoria de proyecto (via GEMINI.md o persistencia interna) puede incluso ayudar a correlacionar un commit con requisitos. Por ejemplo, si en GEMINI.md está listado “Requisito 5: el sistema debe validar emails”, y el commit supuestamente implementa eso, Gemini podría verificar si efectivamente se cubre todo lo mencionado en el requisito. Además, su habilidad de explicar en lenguaje natural brilla aquí: puede producir reseñas amigables pero útiles. **Gemini CLI ofrece análisis de diffs robusto** y es posiblemente uno de sus casos de uso estrella dentro de un equipo (menos propenso a alucinaciones que un modelo más pequeño, gracias a su entrenamiento amplio y contexto).

*Copilot CLI* de nuevo no entra a leer diffs. Una posible usabilidad es que uno copie un diff y pregunte “¿qué comando aplico para revertir este commit?” – Copilot CLI sugeriría `git revert` – pero eso es tangencial. No hace análisis semántico del cambio.

### 8. Solicitudes de cambio en requerimientos (adaptación de documentos)

Este caso trata sobre pedir al asistente que, dado un cambio deseado (por ejemplo, “El cliente pide que el módulo X ahora maneje usuarios invitados”), nos ayude a actualizar los documentos de requisitos o especificaciones de manera organizada. Aquí se mezcla la generación de texto formal con entendimiento de contexto del sistema.

*Claude Code* puede sin duda ayudar a reescribir documentación. Si le proveemos la especificación original (o la tiene en contexto) y describimos la modificación solicitada, podría generar un nuevo documento o secciones actualizadas reflejando el cambio. Por ejemplo, “Actualiza el apartado de *Requisitos Funcionales* para incluir soporte multi-moneda” – Claude podría producir párrafos añadidos o modificados articuladamente. Su modelo es muy bueno escribiendo en distintos tonos (puede hacer redacciones formales, listas numeradas, tablas, etc. si se lo pides). No tiene una herramienta específica de “document writer”, pero este tipo de output es manejado vía la generación libre de texto. Además, con sub-agente, podríamos tener uno enfocado en documentación que use un lenguaje más formal y normativo. En conclusión, **Claude es útil como asistente de documentación**, asegurándose de que los cambios queden consistentes con el estilo del resto del documento (especialmente si le mostramos ejemplos del documento existente para imitar el formato).

*Gemini CLI* igualmente puede encargarse de esta tarea. De hecho, Google menciona *content generation* como uno de los usos de Gemini CLI[<sup>{116}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=power%20to%20your%20command%20line,offering%20AI%20help%20in%20both). Podemos considerarlo un primo de modelos como Bard o ChatGPT pero con contexto de desarrollo. Si en GEMINI.md ponemos la plantilla de un documento de requisitos, podríamos luego pedir “genera la versión actualizada de este doc incorporando X cambio”. Gemini, con su capacidad, produciría la nueva sección de requisitos impactados, tal vez enumerando qué se modifica. Adicionalmente, su conexión a internet no es tan relevante aquí (a menos que quiera comparar con estándares), pero su gran contexto sí: podría reescribir un documento de 50 páginas manteniendo coherencia, porque puede abarcarlo completo en memoria. **Gemini CLI es muy capaz para redactar o adaptar documentación**, lo cual también beneficia a escribir changelogs o notas de versión cuando se hacen cambios (tarea similar donde hay que resumir cambios en texto continuo).

*Copilot CLI* no realiza tareas de procesamiento de lenguaje extenso, así que no ayudaría a editar un documento de requisitos. A lo sumo, podría sugerir un comando para abrir el documento en vim 😅, pero no su contenido.

### Tabla: Adecuación de cada asistente a casos de uso clave

Para mayor claridad, se resume en la siguiente tabla el grado de aptitud de cada herramienta para los distintos casos de uso discutidos:

| Caso de uso 📌 | Claude Code (Anthropic) | Gemini CLI (Google) | GitHub Copilot CLI (GitHub) |
|----|----|----|----|
| **1. Análisis de requerimientos** (consistencia, vacíos) | ✅ *Muy capaz:* Puede leer docs largos, identificar contradicciones con su comprensión global[<sup>{67}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,where%20everything%20is). Sin flujo dedicado pero responde bien a consultas analíticas. | ✅ *Muy capaz:* Contexto 1M tokens para ingerir requisitos completos. Brinda análisis apoyado en su comprensión e info web. | ❌ *No aplicable:* No diseñado para analizar texto de requisitos. |
| **2. Generación de código** a partir de especificaciones | ✅ *Excelente:* Actúa como par programador, implementa funcionalidades autónomamente[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Puede crear múltiples archivos y coordinar cambios. | ✅ *Excelente:* Modo agente multi-paso crea código, tests, etc.[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). Integrado con IDE para flujo iterativo. | ❌ *No:* No genera código fuente (solo comandos CLI). |
| **3. Revisión de código** (estándares, mejores prácticas) | ✅ *Fuerte:* Analiza proyecto o diff y sugiere mejoras. Útil en PRs (integración CI)[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Sub-agente revisor configurable para enfoques específicos. | ✅ *Fuerte:* Ofrece revisión automatizada de PRs con feedback contextual[<sup>{103}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Puede utilizar web para validar prácticas. | ❌ *No:* No lee ni comenta código. (Copilot Chat/PR son otros productos). |
| **4. Debug y corrección de errores** | ✅ *Sí:* Ejecuta tests/código via Bash, interpreta trazas y corrige código en ciclo. Delegación a sub-agente “debugger” posible. | ✅ *Sí:* Ejecuta build/tests, detecta fallos y reitera correcciones automáticamente[<sup>{118}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=agent%20mode%2C%20and%20Code%20Assist,may%20not%20have%20even%20imagined). Busca soluciones conocidas en web si hace falta. | ❌ *No:* No ejecuta código ni analiza errores de ejecución. |
| **5. Generación de pruebas unitarias** | ✅ *Sí:* Genera archivos de test en base a código/requerimientos. Puede ejecutar las pruebas luego para verificar. | ✅ *Sí:* Incluido en sus casos de uso principales[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined). Capaz de alta cobertura usando su contexto de requisitos. | ❌ *No:* No produce código de prueba (Copilot en IDE sí lo haría, pero CLI no). |
| **6. Refactorización por cambios de requerimiento** | ✅ *Excelente:* Refactors globales consistentes. Mantiene conocimiento de todas referencias a modificar[<sup>{67}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,where%20everything%20is). Presenta *diffs* claros para revisión. | ✅ *Excelente:* Agente planifica migraciones y las ejecuta. Integración con herramientas (grep, etc.) para encontrar y cambiar ocurrencias. | ❌ *No:* Fuera de su alcance (no modifica código). |
| **7. Análisis de commits/PRs** (qué cambió, impacto) | ✅ *Sí:* Resume diffs, explica motivos, detecta posibles issues. Útil como reviewer en GitHub (via Actions). | ✅ *Sí:* Responde a PRs con análisis detallado[<sup>{103}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action). Puede vincular cambios con requerimientos conocidos. | ❌ *No:* No comprende ni resume diffs. |
| **8. Adaptación de documentos de requisitos** (solicitud de cambio) | ✅ *Sí:* Redacta modificaciones en lenguaje formal, manteniendo coherencia con doc existente. Usa contexto del documento dado. | ✅ *Sí:* Genera textos formales (tiene capacidades de generación de contenido narrativo[<sup>{116}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=power%20to%20your%20command%20line,offering%20AI%20help%20in%20both)). Contexto masivo útil para docs largos. | ❌ *No:* No genera documentación ni edita textos largos. |

(Legendas: ✅ Capaz/adecuado, ❌ No soportado, - en blanco = no aplicable/directo)

## Conclusiones

En esta comparativa profunda, hemos explorado cómo Claude Code, Gemini CLI y GitHub Copilot CLI se posicionan en el emergente panorama de asistentes de programación vía línea de comandos. A modo de resumen final:

- **Claude Code (Anthropic)** se presenta como un **ingeniero autónomo en tu terminal**, con fuerte orientación a empresas (énfasis en privacidad, control de permisos y despliegue en entornos propios) y capacidades “agénticas” avanzadas. Destaca por entender proyectos enteros y realizar tareas complejas de forma automática (ediciones múltiples, ejecución de pruebas, integración con flujos Git)[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits). Su integración con IDEs mediante atajos y diffs mejora la experiencia del desarrollador. La extensibilidad mediante sub-agentes y hooks permite personalizarlo para distintas necesidades. Como contra, es un producto cerrado y su uso intensivo con el API de Anthropic puede implicar costos (no hay *free tier* amplio; es pago por consumo). En Windows funciona bien vía terminal VSCode o WSL, aunque requiere configurar el comando `code` en PATH[<sup>{10}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Install%20%E2%80%98code%E2%80%99%20command%20in%20PATH%E2%80%9D). En resumen, Claude Code es ideal para quien busca un **asistente de IA todo-en-uno que escriba y modifique código proactivamente**, con control granular pero sin necesidad de trastear con su funcionamiento interno.

- **Gemini CLI (Google)** es el **retador de código abierto** que trae la potencia del modelo Gemini 2.5 a todos los desarrolladores con una propuesta muy generosa (acceso gratuito con altos límites)[<sup>{50}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%2A%20Free%20%26%20high,it%20in%20scripts%20for%20automation). Integra de manera fluida con las herramientas de Google (VS Code Code Assist, Google Cloud) y aporta extras valiosos: integración nativa con la web para información actualizada[<sup>{66}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Its%20power%20comes%20from%20built,tools%20allowing%20you%20to), y un enfoque extensible mediante MCP y configuraciones (GEMINI.md) que lo hacen adaptable a múltiples flujos de trabajo[<sup>{86}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=ideas%20github,GitHub%20repo). Al ser open source, ya cuenta con amplio interés (más de 70k estrellas en GitHub en poco tiempo[<sup>{122}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=,Star%2070.9k)[<sup>{123}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Apache)) y seguramente verá rápidas mejoras impulsadas por la comunidad. Es ideal para quienes valoran la **transparencia y personalización total**, o para equipos que quieran aprovechar su entorno Google (por ejemplo, integración con Vertex AI para cumplimiento corporativo). En casos de uso, es tan capaz como Claude en la mayoría de categorías, con la diferencia de que *requiere quizás un poco más de configuración inicial* (autenticación, ajuste de alguna que otra opción) pero a cambio **democratiza el acceso a un modelo muy potente sin costo de entrada**.

- **GitHub Copilot CLI** representa un tipo de asistente más acotado pero práctico: es como un **“súper buscador de comandos”** que entiende lenguaje natural. Para desarrolladores que pasan mucho tiempo en la terminal, puede acelerar tareas recordando comandos tediosos o enseñando sintaxis desconocidas (por ejemplo, combinaciones complejas de `find`/`grep`/`awk`)[<sup>{124}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=GitHub%20Copilot%20can%20suggest%20commands)[<sup>{125}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Generic%20shell%20commands). Se integra perfectamente con flujos Git/GitHub, lo cual no es sorpresa siendo de GitHub: pedir comandos `git` o `gh` es especialmente cómodo con él[<sup>{126}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=In%20our%20recent%20blog%2C%20we,directly%20from%20the%20command%20line)[<sup>{25}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=GitHub%20commands). Sin embargo, fuera de eso, no compite con Claude o Gemini en labores de generación o análisis de código. Más bien podría verse como complemento: uno podría usar Copilot CLI para agilizar comandos de entorno mientras usa Copilot Chat o otro asistente para el código en sí. Al estar ya en versión estable y provisto por GitHub, su fortaleza es la **comodidad y fiabilidad en su nicho** (no va a modificar tu código sin permiso, siempre te pregunta y explica[<sup>{63}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=,language%20to%20GitHub%20CLI%20commands)[<sup>{65}</sup>](https://github.com/github/gh-copilot#:~:text=%3F%20Select%20an%20option%20,Execute%20command)). Es especialmente útil para desarrolladores menos familiarizados con la terminal, ya que actúa de tutor. Para nuestros casos de uso extensos, Copilot CLI no aporta mucho, pero sigue siendo una herramienta valiosa en el cinturón del desarrollador para tareas diarias en la consola.

En conclusión, si buscas un **asistente de IA integral para desarrollo de software en la terminal**, tanto Claude Code como Gemini CLI ofrecen capacidades de última generación para entender y transformar tu base de código conforme a tus indicaciones. Claude actualmente provee una experiencia más pulida en entornos empresariales con restricciones, mientras que Gemini CLI apuesta por abrir la innovación a todos y promete un rápido avance gracias a la colaboración abierta. Por otro lado, GitHub Copilot CLI, aunque limitado en alcance, cumple un rol específico que puede mejorar la eficiencia en la línea de comandos. La elección puede depender del **ecosistema** en el que te encuentres y las **prioridades**: control y privacidad (Claude), apertura y costo (Gemini), o simplemente mejorar la interfaz de comandos (Copilot CLI).

Con el vertiginoso progreso en esta área, es posible que veamos convergencias en el futuro (por ejemplo, que Copilot incorpore más capacidades “agentic” o que Claude/Gemini simplifiquen algunas interacciones). Pero a la fecha de este informe, estas tres herramientas representan lo más avanzado en asistentes de codificación vía CLI, cada una con su sabor distintivo, y juntas auguran una **nueva era de desarrollo guiado por IA** directamente desde nuestros editores y terminales de siempre.

**Fuentes consultadas:** Documentación oficial de Anthropic[<sup>{6}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=Features)[<sup>{43}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Tool%20Description%20Permission%20Required%20Bash,displays%20Jupyter%20notebook%20contents%20No), Google Cloud[<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code)[<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts), y GitHub[<sup>{58}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=GitHub%20Copilot%20CLI%20translates%20natural,use%20the%20following%20three%20command)[<sup>{21}</sup>](https://github.com/github/gh-copilot#:~:text=Welcome%20to%20GitHub%20Copilot%20in,21); anuncios y blogs técnicos relevantes[<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits)[<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined); experiencias de usuarios en foros y demostraciones de YouTube; Prompt Security research[<sup>{127}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Claude%20Code%3A%20Anthropic%27s%20AI%20Pair,Programmer%20in%20the%20Terminal)[<sup>{128}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,as). Cada afirmación sobre funcionalidades ha sido respaldada con referencias en línea a dichos recursos para mayor detalle y verificación. Los números de línea en las citas corresponden a las ubicaciones precisas en dichos documentos donde se describe la característica mencionada.

------------------------------------------------------------------------

- @anthropic-ai/claude-code - npm: <https://www.npmjs.com/package/@anthropic-ai/claude-code>
  [<sup>{1}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=1) [<sup>{2}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=Version) [<sup>{28}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=1) [<sup>{81}</sup>](https://www.npmjs.com/package/@anthropic-ai/claude-code#:~:text=Claude%20Code%20is%20an%20agentic,or%20tag%20%40claude%20on%20Github)

- AI Coding Assistants for Terminal: Claude Code, Gemini CLI & Qodo Compared: <https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback>
  [<sup>{3}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=settings%20with%20sensitive%20code.%20,start%20an%20interactive%20CLI%20session) [<sup>{11}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Gemini%20CLI%3A%20Google%27s%20Open) [<sup>{12}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=hackable%20and%20integrable.%20,changer%20in%20this%20space) [<sup>{45}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=everything%20is.%20%2A%20Built,enterprise%20settings%20with%20sensitive%20code) [<sup>{50}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%2A%20Free%20%26%20high,it%20in%20scripts%20for%20automation) [<sup>{67}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,where%20everything%20is) [<sup>{68}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=%28e,MultiEdit%20for%20making%20broad%20edits) [<sup>{80}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,MultiEdit%20for%20making%20broad%20edits) [<sup>{112}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Qodo%20Gen%20CLI%20,tailored%20to%20your%20project%27s%20needs) [<sup>{113}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=improvements%2C%20a%20test%20generation%20agent,agnostic.%20It) [<sup>{114}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Claude%20Code%3A%20Anthropic%27s%20AI%20Pair,Programmer%20in%20the%20Terminal) [<sup>{120}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=say%2C%20monitors%20your%20repo%20for,For%20advanced%20cases%2C%20you%20can) [<sup>{127}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=Claude%20Code%3A%20Anthropic%27s%20AI%20Pair,Programmer%20in%20the%20Terminal) [<sup>{128}</sup>](https://www.prompt.security/blog/ai-coding-assistants-make-a-cli-comeback#:~:text=,as)

- Add Claude Code to your IDE - Anthropic: <https://docs.anthropic.com/en/docs/claude-code/ide-integrations>
  [<sup>{4}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=VSCodium%3A) [<sup>{5}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=2,install) [<sup>{6}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=Features) [<sup>{7}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=shared%20with%20Claude%20Code%20,with%20Claude%20as%20you%20work) [<sup>{8}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Studio%2C%20WebStorm%2C%20PhpStorm%20and%20GoLand) [<sup>{9}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=To%20install%20Claude%20Code%20on,marketplace%20and%20restart%20your%20IDE) [<sup>{10}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Install%20%E2%80%98code%E2%80%99%20command%20in%20PATH%E2%80%9D) [<sup>{33}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=1,install) [<sup>{34}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,from%20the%20IDE%20are) [<sup>{35}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=instead%20of%20the%20terminal,with%20Claude%20as%20you%20work) [<sup>{48}</sup>](https://docs.anthropic.com/en/docs/claude-code/ide-integrations#:~:text=,Alt%2BCtrl%2BK)

- [<sup>{13}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Choose%20the%20authentication%20method%20that,best%20fits%20your%20needs) [<sup>{14}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Option%202%3A%20Gemini%20API%20Key) [<sup>{31}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Benefits%3A) [<sup>{32}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%E2%9C%A8%20Best%20for%3A%20Developers%20who,control%20or%20paid%20tier%20access) [<sup>{83}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=,in%20scripts%20for%20workflow%20automation) [<sup>{84}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Using%20MCP%20Servers) [<sup>{85}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=custom%20tools%3A) [<sup>{87}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%2A%20Built,Build%20your%20own%20commands) [<sup>{88}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%2A%20Multi,Build%20your%20own%20commands) [<sup>{89}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=GitHub%20Integration) [<sup>{90}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action) [<sup>{91}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=%23%20Non) [<sup>{92}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=) [<sup>{103}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Integrate%20Gemini%20CLI%20directly%20into,with%20Gemini%20CLI%20GitHub%20Action) [<sup>{122}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=,Star%2070.9k) [<sup>{123}</sup>](https://github.com/google-gemini/gemini-cli#:~:text=Apache) GitHub - google-gemini/gemini-cli: An open-source AI agent that brings the power of Gemini directly into your terminal.

<https://github.com/google-gemini/gemini-cli>

- [<sup>{15}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=content%20generation%20and%20problem%20solving,deep%20research%20and%20task%20management) [<sup>{16}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=We%E2%80%99ve%20also%20integrated%20Gemini%20CLI,VS%20Code%20and%20Gemini%20CLI) [<sup>{36}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20Code%20Assist%2C%20Google%E2%80%99s%20AI,may%20not%20have%20even%20imagined) [<sup>{66}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Its%20power%20comes%20from%20built,tools%20allowing%20you%20to) [<sup>{82}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,interactively%20within%20your%20scripts) [<sup>{86}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=ideas%20github,GitHub%20repo) [<sup>{93}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Because%20Gemini%20CLI%20is%20fully,ideas%20in%20our%20GitHub%20repo) [<sup>{94}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=implications,ideas%20in%20our%20GitHub%20repo) [<sup>{115}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Gemini%20CLI%20is%20here%20to,AI%20key%20for%20more%20access) [<sup>{116}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=power%20to%20your%20command%20line,offering%20AI%20help%20in%20both) [<sup>{117}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=Sometimes%2C%20an%20IDE%20is%20the,learn%20and%20overcome%20issues%20quickly) [<sup>{118}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=agent%20mode%2C%20and%20Code%20Assist,may%20not%20have%20even%20imagined) [<sup>{119}</sup>](https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/#:~:text=,workflows%20by%20invoking%20Gemini%20CLI) Google announces Gemini CLI: your open-source AI agent

<https://blog.google/technology/developers/introducing-gemini-cli-open-source-ai-agent/>

- [<sup>{17}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20Code%20Assist%20agent%20mode) [<sup>{18}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20following%20Gemini%20CLI%20features,Code%20Assist%20for%20VS%20Code) [<sup>{19}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20Code%20Assist%20for%20individuals%2C,Gemini%20Code%20Assist%20agent%20mode) [<sup>{37}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=Gemini%20CLI%20and%20Gemini%20Code,Assist%20agent%20mode) [<sup>{49}</sup>](https://cloud.google.com/gemini/docs/codeassist/gemini-cli#:~:text=The%20Gemini%20command%20line%20interface,deep%20research%20and%20task%20management) Gemini CLI  \|  Gemini for Google Cloud

<https://cloud.google.com/gemini/docs/codeassist/gemini-cli>

- [<sup>{20}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Copilot%20in%20the%20CLI%20is,here%20will%20be%20Windows%20PowerShell) [<sup>{25}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=GitHub%20commands) [<sup>{26}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=https%3A%2F%2Fgithub.blog%2Fwp) [<sup>{52}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Explaining%20concepts%20is%20good%20for,for%20you%20to%20choose%20from) [<sup>{53}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=The%20user%20can%20choose%20between%3A) [<sup>{54}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Generic%20shell%20commands) [<sup>{55}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Along%20the%20way%2C%20we%20are,or%20exit%20the%20current%20question) [<sup>{56}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=You%20can%20receive%20help%20from,does%2C%20I%20can%20ask%20Copilot) [<sup>{57}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=%60npx%20sirv,does%2C%20I%20can%20ask%20Copilot) [<sup>{69}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Have%20GitHub%20Copilot%20explain%20computer,science%20concepts) [<sup>{124}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=GitHub%20Copilot%20can%20suggest%20commands) [<sup>{125}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=Generic%20shell%20commands) [<sup>{126}</sup>](https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/#:~:text=In%20our%20recent%20blog%2C%20we,directly%20from%20the%20command%20line) Boost your CLI skills with GitHub Copilot - The GitHub Blog

<https://github.blog/developer-skills/programming-languages-and-frameworks/boost-your-cli-skills-with-github-copilot/>

- [<sup>{21}</sup>](https://github.com/github/gh-copilot#:~:text=Welcome%20to%20GitHub%20Copilot%20in,21) [<sup>{22}</sup>](https://github.com/github/gh-copilot#:~:text=Releases%2013) [<sup>{23}</sup>](https://github.com/github/gh-copilot#:~:text=echo%20%27eval%20,%3E%3E%20~%2F.bashrc) [<sup>{24}</sup>](https://github.com/github/gh-copilot#:~:text=echo%20%27eval%20,%3E%3E%20~%2F.zshrc) [<sup>{38}</sup>](https://github.com/github/gh-copilot#:~:text=PowerShell) [<sup>{51}</sup>](https://github.com/github/gh-copilot#:~:text=Available%20Commands%3A%20alias%20%20,Suggest%20a%20command) [<sup>{59}</sup>](https://github.com/github/gh-copilot#:~:text=Is%20,and%20keeping%20them%20in%20history) [<sup>{60}</sup>](https://github.com/github/gh-copilot#:~:text=v1.0.0%20introduces%20,shell%20history%20for%20reuse%20later) [<sup>{61}</sup>](https://github.com/github/gh-copilot#:~:text=) [<sup>{62}</sup>](https://github.com/github/gh-copilot#:~:text=%24%20gh%20copilot%20config) [<sup>{65}</sup>](https://github.com/github/gh-copilot#:~:text=%3F%20Select%20an%20option%20,Execute%20command) [<sup>{96}</sup>](https://github.com/github/gh-copilot#:~:text=explain,shell%20history%20for%20reuse%20later) [<sup>{97}</sup>](https://github.com/github/gh-copilot#:~:text=) [<sup>{98}</sup>](https://github.com/github/gh-copilot#:~:text=For%20more%20information%2C%20run%20,help) GitHub - github/gh-copilot: Ask for assistance right in your terminal.

<https://github.com/github/gh-copilot>

- [<sup>{27}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=Supported%20platforms) [<sup>{58}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=GitHub%20Copilot%20CLI%20translates%20natural,use%20the%20following%20three%20command) [<sup>{63}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=,language%20to%20GitHub%20CLI%20commands) [<sup>{95}</sup>](https://www.npmjs.com/package/@githubnext/github-copilot-cli#:~:text=You%20can%20run%20GitHub%20Copilot,them%2C%20run%20the%20following%20command) @githubnext/github-copilot-cli - npm

<https://www.npmjs.com/package/@githubnext/github-copilot-cli>

- [<sup>{29}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=,Name%20of%20%2032) [<sup>{30}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=%60CLAUDE_CODE_IDE_SKIP_AUTO_INSTALL%20%60Skip%20auto,when%20using%20an%20LLM%20gateway) [<sup>{39}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Claude%20Code%20has%20access%20to,understand%20and%20modify%20your%20codebase) [<sup>{40}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=MultiEdit%20Performs%20multiple%20edits%20on,Creates%20or%20overwrites%20files%20Yes) [<sup>{41}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=To%20manage%20your%20configurations%2C%20use,the%20following%20commands) [<sup>{43}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Tool%20Description%20Permission%20Required%20Bash,displays%20Jupyter%20notebook%20contents%20No) [<sup>{44}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Read%20Reads%20the%20contents%20of,Creates%20or%20overwrites%20files%20Yes) [<sup>{46}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Task%20Runs%20a%20sub,Creates%20or%20overwrites%20files%20Yes) [<sup>{47}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Permission%20rules%20can%20be%20configured,tools%60%20or%20in%20permission%20settings) [<sup>{64}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=NotebookEdit%20Modifies%20Jupyter%20notebook%20cells,Creates%20or%20overwrites%20files%20Yes) [<sup>{70}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Extending%20tools%20with%20hooks) [<sup>{71}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Claude%20Code%20supports%20custom%20AI,Markdown%20files%20with%20YAML%20frontmatter) [<sup>{72}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Subagent%20files%20define%20specialized%20AI,subagents%20in%20the%20subagents%20documentation) [<sup>{78}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=,5%20when) [<sup>{79}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=critical%20paths%20like%20flavor%20text,file%20paths%2C%20or%20bash%20commands) [<sup>{101}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Variable%20Purpose%20,Name%20of%20%2032) [<sup>{102}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=,critical%20paths%20like%20flavor%20text) [<sup>{121}</sup>](https://docs.anthropic.com/en/docs/claude-code/settings#:~:text=Grep%20Searches%20for%20patterns%20in,from%20a%20specified%20URL%20Yes) Claude Code settings - Anthropic

<https://docs.anthropic.com/en/docs/claude-code/settings>

- [<sup>{42}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Open%20the%20subagents%20interface) [<sup>{73}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20are%20pre,Each%20subagent) [<sup>{74}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=%3E%20Use%20the%20code,to%20check%20my%20recent%20changes) [<sup>{100}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=File%20locations) [<sup>{104}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Each%20subagent%20is%20defined%20in,Markdown%20file%20with%20this%20structure) [<sup>{105}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Configuration%20fields) [<sup>{106}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=,prompt%20that%20guides%20its%20behavior) [<sup>{107}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=%3E%20Use%20the%20code,to%20check%20my%20recent%20changes) [<sup>{108}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Context%20preservation) [<sup>{109}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=1) [<sup>{110}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Select%20%27Create%20New%20Agent%27) [<sup>{111}</sup>](https://docs.anthropic.com/en/docs/claude-code/sub-agents#:~:text=Subagents%20can%20be%20fine,success%20rates%20on%20designated%20tasks) Subagents - Anthropic

<https://docs.anthropic.com/en/docs/claude-code/sub-agents>

- [<sup>{75}</sup>](https://intuitionlabs.ai/articles/mcp-servers-claude-code-internet-search#:~:text=,Web%20Search%20MCP%20by) Integrating MCP Servers for Web Search with Claude Code ...

<https://intuitionlabs.ai/articles/mcp-servers-claude-code-internet-search>

- [<sup>{76}</sup>](https://playbooks.com/mcp/power3xz-youtube-transcript#:~:text=For%20Claude%20Code,transcript%22%20%27%7B%22command) YouTube Transcript MCP server for AI agents - Playbooks

<https://playbooks.com/mcp/power3xz-youtube-transcript>

- [<sup>{77}</sup>](https://playbooks.com/mcp/jkawamoto-youtube-transcript#:~:text=YouTube%20Transcripts%20MCP%20server%20for,transcript%22%20%27%7B%22command%22%3A%22uvx%22%2C%22args) YouTube Transcripts MCP server for AI agents - Playbooks

<https://playbooks.com/mcp/jkawamoto-youtube-transcript>

- [<sup>{99}</sup>](https://www.reddit.com/r/commandline/comments/1doj06s/the_official_github_copilot_cli_is_really_bad/#:~:text=The%20official%20GitHub%20Copilot%20Cli,set%20up%20and%20straightforward%20use) The official GitHub Copilot Cli is really bad, there seem to be ...

<https://www.reddit.com/r/commandline/comments/1doj06s/the_official_github_copilot_cli_is_really_bad/>
